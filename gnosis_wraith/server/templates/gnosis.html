
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gnosis Wraith | Minimal Interface</title>
    
    <!-- React and ReactDOM -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.development.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.development.js"></script>
    
    <!-- Babel for JSX -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.21.2/babel.min.js"></script>
    <!-- NOTE FOR PRODUCTION: Replace the above with precompiled JSX for production environments -->
    
    <!-- Tailwind CSS - Using specific version with production mode to avoid warnings -->
    <script src="https://cdn.tailwindcss.com?plugins=forms,typography,aspect-ratio"></script>
    <script>
      tailwind.config = {
        mode: 'jit',
        darkMode: 'class',
        theme: {
          extend: {
            colors: {
              'terminal-green': '#4ade80',
            }
          }
        }
      }
    </script>
    
    <!-- Font Awesome -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    
    <!-- Custom styles for word wrapping -->
    <style>
        /* Custom CSS for word wrapping long URLs */
        .break-words {
            word-wrap: break-word;
            word-break: break-word;
            overflow-wrap: break-word;
            -ms-word-break: break-all;
            -ms-hyphens: auto;
            -moz-hyphens: auto;
            -webkit-hyphens: auto;
            hyphens: auto;
        }
        .overflow-wrap-anywhere {
            overflow-wrap: anywhere;
        }
        
        /* JSON display styling */
        .json-container {
            position: relative;
            margin: 4px 0;
            transition: all 0.2s ease;
        }
        .json-container:hover {
            box-shadow: 0 0 10px rgba(108, 99, 255, 0.2);
        }
        .json-content {
            white-space: pre-wrap !important;  /* Important to override any inline styles */
            word-break: break-all !important;  /* Force break anywhere needed */
            overflow-wrap: break-word !important;
            word-wrap: break-word !important;  /* For IE/Edge */
            padding: 6px;
            line-height: 1.4;
            max-width: 100%;
        }
        .json-content span {
            word-break: break-all !important; /* Break even within words if needed */
            overflow-wrap: anywhere !important; /* Modern browsers */
            display: inline-block !important; /* Allow long strings to wrap */
            max-width: 100% !important;
            white-space: pre-wrap !important; /* Allow wrapping */
        }
        /* Special handling for URLs and other long strings */
        .json-content .text-green-400 {
            word-break: break-all !important;
            max-width: calc(100% - 10px) !important;
        }
        .toggle-json {
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .toggle-json:hover {
            background-color: rgba(108, 99, 255, 0.2) !important;
        }
        
        /* URL and report info styling */
        .log-url-info {
            margin: 4px 0;
            padding: 4px 6px;
            border-radius: 4px;
            background-color: rgba(50, 50, 70, 0.3);
        }
        .report-link {
            transition: all 0.2s ease;
        }
        .report-link:hover {
            box-shadow: 0 0 10px rgba(72, 187, 120, 0.3);
        }
        /* Ensure the body and html fill the entire viewport with dark background */
        html, body {
            height: 100vh;
            background-color: #111827; /* bg-gray-900 equivalent */
            margin: 0;
            padding: 0;
            overflow: hidden;
        }
        /* Allow scrolling within containers but fit content in viewport */
        body {
            height: 100vh;
        }
        /* Ensure containers with overflow can scroll */
        .log-container {
            overflow-y: auto !important;
            position: relative;
        }
        
        /* CRT Scan Lines Effect */
        .crt-scanlines::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: repeating-linear-gradient(
                0deg,
                transparent,
                transparent 2px,
                rgba(0, 255, 0, 0.03) 2px,
                rgba(0, 255, 0, 0.03) 4px
            );
            pointer-events: none;
            z-index: 1;
        }
        
        /* CRT Flicker Animation */
        .crt-flicker {
            animation: flicker 0.15s infinite linear;
        }
        
        @keyframes flicker {
            0% { opacity: 1; }
            98% { opacity: 1; }
            99% { opacity: 0.98; }
            100% { opacity: 1; }
        }
        
        /* Random flicker trigger */
        .crt-flicker.active {
            animation: flicker-strong 0.1s ease-in-out;
        }
        
        @keyframes flicker-strong {
            0% { opacity: 1; }
            50% { opacity: 0.8; }
            100% { opacity: 1; }
        }
        
        /* CRT Glow Effect */
        .crt-glow {
            text-shadow: 0 0 5px #00ff00, 0 0 10px #00ff00, 0 0 15px #00ff00;
        }
    </style>
</head>
<body class="bg-gray-900 p-0 m-0">
    <div id="root"></div>
    
    <script type="text/babel">
        {% raw %}
        // React hooks are globally available
        const { useState, useEffect, useRef } = React;
        
        const GnosisWraithInterface = () => {
  const [authStatus, setAuthStatus] = useState('unauthorized');
  const [inputValue, setInputValue] = useState('');
  const [systemStatus, setSystemStatus] = useState('initializing');
  const [healthCheckInterval, setHealthCheckInterval] = useState(null);
  const [logs, setLogs] = useState([]);
  const [crawlStats, setCrawlStats] = useState({
    total: 0,
    success: 0,
    errors: 0,
    lastUrl: ''
  });
  const [urlHistory, setUrlHistory] = useState([]);
  const [showHistory, setShowHistory] = useState(false);
  const [reportFormat, setReportFormat] = useState('md'); // Default to Markdown
  const [forceJavascript, setForceJavascript] = useState(false); // Force JavaScript toggle
  const [screenshotMode, setScreenshotMode] = useState('full'); // Default to full screenshots
  const [markdownQuality, setMarkdownQuality] = useState('enhanced'); // Default to enhanced markdown
  const logsEndRef = useRef(null);
  
  // Use localStorage to persist settings
  useEffect(() => {
    // Check if a valid auth code exists in localStorage or cookies
    let storedAuthCode = localStorage.getItem('gnosis_auth_code');
    
    // If not in localStorage, check cookies
    if (!storedAuthCode) {
      const getCookie = (name) => {
        const nameEQ = `${name}=`;
        const ca = document.cookie.split(';');
        for (let i = 0; i < ca.length; i++) {
          let c = ca[i];
          while (c.charAt(0) === ' ') c = c.substring(1);
          if (c.indexOf(nameEQ) === 0) {
            return c.substring(nameEQ.length, c.length);
          }
        }
        return '';
      };
      storedAuthCode = getCookie('gnosis_auth_code');
    }
    
    if (storedAuthCode && /^c0d3z\d{4}$/i.test(storedAuthCode)) {
      // Auto-authenticate if valid code exists
      setAuthStatus('authorized');
    }
    
    // Load URL history from localStorage
    try {
      const storedHistory = localStorage.getItem('gnosis_url_history');
      if (storedHistory) {
        setUrlHistory(JSON.parse(storedHistory));
      }
    } catch (e) {
      console.error('Error loading URL history:', e);
    }
    
    // Load report format preference from localStorage
    try {
      const storedFormat = localStorage.getItem('gnosis_report_format');
      if (storedFormat && ['md', 'html', 'png'].includes(storedFormat)) {
        setReportFormat(storedFormat);
      }
    } catch (e) {
      console.error('Error loading report format preference:', e);
    }
    
    // Load force JavaScript preference from localStorage
    try {
      const storedForceJs = localStorage.getItem('gnosis_force_javascript');
      if (storedForceJs === 'true') {
        setForceJavascript(true);
      }
    } catch (e) {
      console.error('Error loading force JavaScript preference:', e);
    }
    
    // Load screenshot mode preference from localStorage
    try {
      const storedScreenshotMode = localStorage.getItem('gnosis_screenshot_mode');
      if (storedScreenshotMode && ['off', 'top', 'full'].includes(storedScreenshotMode)) {
        setScreenshotMode(storedScreenshotMode);
      }
    } catch (e) {
      console.error('Error loading screenshot mode preference:', e);
    }
    
    // Load markdown quality preference from localStorage
    try {
      const storedMarkdownQuality = localStorage.getItem('gnosis_markdown_quality');
      if (storedMarkdownQuality && ['enhanced', 'basic', 'none'].includes(storedMarkdownQuality)) {
        setMarkdownQuality(storedMarkdownQuality);
      }
    } catch (e) {
      console.error('Error loading markdown quality preference:', e);
    }
    
    // Set log container visibility to true by default
    setLogContainerVisible(true);
    
    // Start health checking immediately
    checkServerHealth();
    
    // Set up periodic health checks every 30 seconds
    const interval = setInterval(checkServerHealth, 30000);
    setHealthCheckInterval(interval);
    
    // Simulate system initialization
    setTimeout(() => {
      addLog('System initialization complete');
      addLog('Gnosis Wraith v3.2.7 ready');
      
      // Check localStorage directly instead of relying on authStatus state
      const storedAuthCode = localStorage.getItem('gnosis_auth_code');
      if (storedAuthCode && /^c0d3z\d{4}$/i.test(storedAuthCode)) {
        addLog('Authentication found in local storage');
        addLog('Distributed crawler system online');
        addLog('Memory banks accessible');
      } else {
        addLog('Awaiting authentication...');
        addLog('Required format: c0d3zXXXX where XXXX is a 4-digit number');
      }
      
      // Load stored crawl stats if they exist
      const storedStats = localStorage.getItem('gnosis_crawl_stats');
      if (storedStats) {
        try {
          const stats = JSON.parse(storedStats);
          // Ensure we have the lastUrl property
          if (!stats.hasOwnProperty('lastUrl')) {
            stats.lastUrl = '';
          }
          setCrawlStats(stats);
          addLog(`Loaded previous session statistics: ${stats.total} crawls`);
        } catch (e) {
          console.error('Error parsing stored crawl stats:', e);
        }
      }
    }, 1500);
    
    // Cleanup interval on unmount
    return () => {
      if (interval) {
        clearInterval(interval);
      }
    };
  }, []);
  
  // Update local storage when crawl stats change
  useEffect(() => {
    // Skip initial render
    if (crawlStats.total > 0) {
      localStorage.setItem('gnosis_crawl_stats', JSON.stringify(crawlStats));
    }
  }, [crawlStats]);
  
  // Store URL history in local storage
  const updateUrlHistory = (url) => {
    // Get existing history or initialize empty array
    let history = [];
    try {
      const storedHistory = localStorage.getItem('gnosis_url_history');
      if (storedHistory) {
        history = JSON.parse(storedHistory);
      }
    } catch (e) {
      console.error('Error parsing URL history:', e);
    }
    
    // Add new URL to history if not a duplicate of the most recent
    if (url && url.trim() && (history.length === 0 || history[0] !== url)) {
      history.unshift(url); // Add to beginning
      history = history.slice(0, 10); // Keep only 10 most recent
      localStorage.setItem('gnosis_url_history', JSON.stringify(history));
    }
    
    return history;
  };
  
  // State to track user scrolling and auto-scrolling settings
  const [isUserScrolling, setIsUserScrolling] = useState(false);
  const [shouldScrollToBottom, setShouldScrollToBottom] = useState(true);
  
  // Auto-scroll logs to bottom when new logs are added or when container becomes visible
  useEffect(() => {
    // Only scroll if there are logs and the log container is visible
    if (logs.length > 0 && 
        logsEndRef && logsEndRef.current && 
        logContainerVisible && 
        !isUserScrolling && 
        shouldScrollToBottom) {
      
      // Only attempt to scroll if we have valid refs
      if (logsEndRef && logsEndRef.current) {
        // Scroll to bottom smoothly
        logsEndRef.current.scrollIntoView({ behavior: 'smooth' });
      }
    }
  }, [logs, logContainerVisible, isUserScrolling, shouldScrollToBottom]);
  
  // Handle scroll events in the log container to detect position
  useEffect(() => {
    const handleScroll = () => {
      if (logContainerRef && logContainerRef.current) {
        const container = logContainerRef.current;
        // Calculate if we're near the bottom
        const isNearBottom = container.scrollHeight - container.scrollTop - container.clientHeight < 100;
        
        // Update auto-scroll flag based on scroll position
        setShouldScrollToBottom(isNearBottom);
      }
    };
    
    // Add scroll event listener to the log container
    const logContainer = logContainerRef && logContainerRef.current ? logContainerRef.current : null;
    if (logContainer) {
      logContainer.addEventListener('scroll', handleScroll);
    }
    
    return () => {
      // Clean up event listener
      if (logContainer) {
        logContainer.removeEventListener('scroll', handleScroll);
      }
    };
  }, []); // Empty dependency array, this only runs on mount and unmount
  
  // Handle mouse down/up to detect when user is actively scrolling
  useEffect(() => {
    const handleMouseDown = () => {
      setIsUserScrolling(true);
    };
    
    const handleMouseUp = () => {
      setIsUserScrolling(false);
      
      // If user releases mouse while near bottom, scroll to bottom immediately
      if (shouldScrollToBottom && 
          logContainerRef && logContainerRef.current && 
          logsEndRef && logsEndRef.current) {
        logsEndRef.current.scrollIntoView({ behavior: 'smooth' });
      }
    };
    
    // Add event listeners to the document
    document.addEventListener('mousedown', handleMouseDown);
    document.addEventListener('mouseup', handleMouseUp);
    
    return () => {
      // Clean up event listeners
      document.removeEventListener('mousedown', handleMouseDown);
      document.removeEventListener('mouseup', handleMouseUp);
    };
  }, [shouldScrollToBottom]);
  
  // CRT flicker effect
  useEffect(() => {
    const flickerInterval = setInterval(() => {
      if (Math.random() < 0.1) { // 10% chance every interval
        const crtElement = logContainerRef.current;
        if (crtElement) {
          crtElement.classList.add('active');
          setTimeout(() => {
            crtElement.classList.remove('active');
          }, 100);
        }
      }
    }, 2000);
    
    return () => clearInterval(flickerInterval);
  }, []);
  
  // Create references
  const logContainerRef = useRef(null);
  const rootContainerRef = useRef(null);
  
  // State to track log container visibility
  const [logContainerVisible, setLogContainerVisible] = useState(false);
  
  // Simple height calculation that fills available space
  useEffect(() => {
    const calculateHeight = () => {
      if (logContainerRef.current && rootContainerRef.current) {
        const viewportHeight = window.innerHeight;
        const logContainer = logContainerRef.current;
        const logRect = logContainer.getBoundingClientRect();
        
        // Calculate available height from current position to bottom of viewport
        const availableHeight = viewportHeight - logRect.top - 20; // 20px bottom margin
        
        // Set minimum height
        const finalHeight = Math.max(300, availableHeight);
        
        // Apply the height
        logContainer.style.height = `${finalHeight}px`;
        logContainer.style.visibility = 'visible';
        setLogContainerVisible(true);
      }
    };
    
    // Initial calculation
    const timer = setTimeout(calculateHeight, 100);
    
    // Handle window resize
    const handleResize = () => {
      calculateHeight();
    };
    
    window.addEventListener('resize', handleResize);
    
    return () => {
      clearTimeout(timer);
      window.removeEventListener('resize', handleResize);
    };
  }, []); // Run once on mount

  const handleInputChange = (e) => {
    setInputValue(e.target.value);
  };
  
  // Search query detection functions removed

  // Helper function to get cookie value
  const getCookie = (name) => {
    const nameEQ = `${name}=`;
    const ca = document.cookie.split(';');
    for (let i = 0; i < ca.length; i++) {
      let c = ca[i];
      while (c.charAt(0) === ' ') c = c.substring(1);
      if (c.indexOf(nameEQ) === 0) {
        return c.substring(nameEQ.length, c.length);
      }
    }
    return '';
  };

  const handleAuthenticate = () => {
    if (inputValue.trim()) {
      setAuthStatus('authenticating');
      addLog(`Authentication attempt: ${inputValue.substring(0, 3)}${'*'.repeat(inputValue.length - 3)}`);
      
      // Check if input is a valid code
      const codePattern = /^c0d3z\d{4}$/i;
      if (codePattern.test(inputValue)) {
        setTimeout(() => {
          // Check if this is a different code than what's currently stored
          const currentStoredCode = localStorage.getItem('gnosis_auth_code') || getCookie('gnosis_auth_code');
          
          if (currentStoredCode && currentStoredCode !== inputValue) {
            // Different code - clear all existing data first
            addLog(`New authentication code detected`);
            addLog(`Clearing previous session data for security`);
            
            // Clear all localStorage except the new auth code we're about to set
            localStorage.clear();
            
            // Clear all cookies
            document.cookie.split(";").forEach(function(c) { 
              document.cookie = c.replace(/^ +/, "").replace(/=.*/, "=;expires=" + new Date().toUTCString() + ";path=/"); 
            });
            
            addLog(`Previous session data cleared`);
          }
          
          setAuthStatus('authorized');
          addLog('Authentication successful');
          addLog(`Access code verified: ${inputValue}`);
          addLog('Distributed crawler system online');
          addLog('Memory banks accessible');
          setInputValue('');
          
          // Store the new auth code in both localStorage and cookies
          localStorage.setItem('gnosis_auth_code', inputValue);
          
          // Also store in cookie with 90 day expiration
          const date = new Date();
          date.setTime(date.getTime() + (90 * 24 * 60 * 60 * 1000));
          const expires = `expires=${date.toUTCString()}`;
          document.cookie = `gnosis_auth_code=${inputValue};${expires};path=/;SameSite=Strict`;
          
          // Log successful auth to server (optional)
          logToServer('authentication', { code: inputValue });
        }, 1000);
      } else if (inputValue.toLowerCase() === 'password') {
        // Legacy password for testing
        setTimeout(() => {
          setAuthStatus('authorized');
          addLog('Legacy authentication successful');
          addLog('Distributed crawler system online');
          addLog('Memory banks accessible');
          addLog('WARNING: Using legacy credentials');
          setInputValue('');
        }, 1000);
      } else {
        // Failed authentication
        setTimeout(() => {
          setAuthStatus('unauthorized');
          addLog('Authentication failed');
          addLog('Access denied: Invalid code format');
          addLog('Required format: c0d3zXXXX where XXXX is a 4-digit number');
          setInputValue('');
        }, 1000);
      }
    }
  };

  // Function to check server health
  const checkServerHealth = async () => {
    try {
      const response = await fetch('/health', {
        method: 'HEAD',
        cache: 'no-cache'
      });
      
      if (response.ok) {
        if (systemStatus !== 'online') {
          setSystemStatus('online');
          console.log('ðŸŸ¢ Health Check: Server is ONLINE (HEAD /health returned 200)');
        }
      } else {
        if (systemStatus !== 'degraded') {
          setSystemStatus('degraded');
          const statusExplanation = getHttpStatusExplanation(response.status);
          console.log(`ðŸŸ¡ Health Check: Server is DEGRADED (HEAD /health returned ${response.status} - ${statusExplanation})`);
          addLog(`Server health check failed: HTTP ${response.status} - ${statusExplanation}`);
        }
      }
    } catch (error) {
      if (systemStatus !== 'offline') {
        setSystemStatus('offline');
        console.log(`ðŸ”´ Health Check: Server is OFFLINE (HEAD /health failed - ${error.message})`);
        addLog(`Server health check failed: ${error.message}`);
      }
    }
  };
  
  // Function to explain HTTP status codes
  const getHttpStatusExplanation = (status) => {
    const statusCodes = {
      400: 'Bad Request',
      401: 'Unauthorized', 
      403: 'Forbidden',
      404: 'Not Found (health endpoint missing)',
      405: 'Method Not Allowed',
      408: 'Request Timeout',
      500: 'Internal Server Error',
      502: 'Bad Gateway',
      503: 'Service Unavailable',
      504: 'Gateway Timeout'
    };
    
    return statusCodes[status] || `HTTP ${status}`;
  };

  // Function to log events to server
  const logToServer = async (eventType, data) => {
    try {
      // Add timestamp to all log entries
      const logData = {
        ...data,
        timestamp: new Date().toISOString(),
        event: eventType
      };
      
      // Log the event to the client console for debugging
      console.log(`Logging to server: ${eventType}`, logData);
      
      // Send the log to server (this would be implemented on the server)
      const response = await fetch('/api/log', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(logData)
      });
      
      // Only add the log to the UI if the server request was successful
      if (response.ok) {
        addLog(`Event logged: ${eventType}`);
      }
    } catch (error) {
      // Silent fail if logging fails - doesn't affect the user experience
      console.error('Error logging to server:', error);
    }
  };

  const handleSearch = async () => {
    if (inputValue.trim()) {
      // Store the query or URL
      let queryUrl = inputValue.trim();
      
      // Don't try to convert non-URL input to URLs - leave as plain text
      // This allows search terms to be passed directly to the API
      
      // Add to URL history and update state
      const updatedHistory = updateUrlHistory(queryUrl);
      setUrlHistory(updatedHistory);
      
      // Update last URL in stats
      setCrawlStats(prev => ({
        ...prev,
        lastUrl: queryUrl
      }));
      
      addLog(`Initiating crawl sequence for: ${queryUrl}`);
      
      try {
        // First check if it's a URL or query
        const isUrl = queryUrl.startsWith('http://') || queryUrl.startsWith('https://') || 
                     /^[a-z0-9]+([\-\.]{1}[a-z0-9]+)*\.[a-z]{2,}$/i.test(queryUrl);
        
        // Just a simple logging message without implying conversion
        addLog(`Processing input: ${queryUrl}`);
        
        // Log crawl attempt to server - don't try to categorize as URL or not
        logToServer('crawl_attempt', { 
          query: queryUrl,
          auth_code: localStorage.getItem('gnosis_auth_code') || 'none'
        });
        
        addLog('Dispatching ethereal agents...');
        
        // Always call the API to get URL suggestions - for both URLs and queries
        try {
          // Get the selected provider and corresponding API key from cookies
          const provider = localStorage.getItem('gnosis_wraith_llm_provider') || 'anthropic';
          
          // Function to get cookie value
          const getCookie = (name) => {
            const nameEQ = `${name}=`;
            const ca = document.cookie.split(';');
            for (let i = 0; i < ca.length; i++) {
              let c = ca[i];
              while (c.charAt(0) === ' ') c = c.substring(1);
              if (c.indexOf(nameEQ) === 0) {
                return c.substring(nameEQ.length, c.length);
              }
            }
            return '';
          };
          
          // Get the API key for the selected provider
          let apiKey = '';
          let cookieName = '';
          
          switch(provider) {
            case 'anthropic':
              cookieName = 'gnosis_wraith_llm_token_anthropic';
              break;
            case 'openai':
              cookieName = 'gnosis_wraith_llm_token_openai';
              break;
            case 'gemini':
              cookieName = 'gnosis_wraith_llm_token_gemini';
              break;
            default:
              cookieName = 'gnosis_wraith_llm_token_anthropic';
          }
          
          apiKey = getCookie(cookieName);
          
          // Log the request before making it
          addLog(`<div class="api-request px-2 py-1 bg-gray-900 rounded border-l-2 border-blue-500 inline-block">
            <span class="text-blue-400 font-mono font-semibold">POST</span>
            <span class="text-gray-400 font-mono">/api/suggest</span>
            <span class="text-yellow-400 font-mono ml-2 px-1.5 py-0.5 bg-yellow-900 bg-opacity-30 rounded">SENDING</span>
          </div>`);
          
          const suggestResponse = await fetch('/api/suggest', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json'
            },
            body: JSON.stringify({ 
              query: queryUrl,
              provider: provider,
              api_key: apiKey || null // Send the user's API key if available
            })
          });
          
          // Log the response status immediately after receiving it
          const statusColor = suggestResponse.ok ? 'text-green-400' : 'text-red-400';
          const statusBg = suggestResponse.ok ? 'bg-green-900' : 'bg-red-900';
          addLog(`<div class="api-request px-2 py-1 bg-gray-900 rounded border-l-2 border-blue-500 inline-block">
            <span class="text-blue-400 font-mono font-semibold">POST</span>
            <span class="text-gray-400 font-mono">/api/suggest</span>
            <span class="${statusColor} font-mono ml-2 px-1.5 py-0.5 ${statusBg} bg-opacity-30 rounded">${suggestResponse.status} ${suggestResponse.statusText}</span>
          </div>`);
          
          let retryCount = 0;
          const maxRetries = 2;
          let suggestSuccess = false;
          
          while (retryCount <= maxRetries && !suggestSuccess) {
            try {
              if (retryCount > 0) {
                addLog(`Retrying URL suggestion (attempt ${retryCount + 1})...`);
              }
              
              if (suggestResponse.ok) {
                const suggestResult = await suggestResponse.json();
                // Always show the JSON response regardless of success status

                
                                  // Response details are already logged above with status code
                  
                  // Format and display JSON with syntax highlighting and collapsible structure
                  const jsonStr = JSON.stringify(suggestResult, null, 2);
                  const formattedJson = formatJsonForDisplay(jsonStr);
                  
                  // Determine styling based on success/error status
                  const isError = suggestResult.success === false;
                  const borderColor = isError ? 'border-red-500' : 'border-purple-500';
                  const bgColor = isError ? 'bg-red-900 bg-opacity-20' : 'bg-gray-900';
                  const statusIcon = isError ? '<i class="fas fa-exclamation-triangle text-red-400 mr-1"></i>' : '';
                  const statusText = isError ? 'ERROR' : 'SUCCESS';
                  const statusColor = isError ? 'text-red-400' : 'text-purple-400';
                  
                  addLog(`<div class="json-container ${bgColor} rounded p-2 my-1 border-l-2 ${borderColor} break-words">
                    <div class="flex justify-between items-center mb-1">
                      <div class="flex items-center">
                        ${statusIcon}<span class="text-xs ${statusColor} font-semibold mr-2">${statusText}</span>
                        <button class="text-xs text-gray-400 hover:text-gray-300 px-2 py-0.5 bg-gray-800 rounded toggle-json" onclick="event.preventDefault(); toggleJsonVisibility(this); return false;">
                          <i class="fas fa-chevron-down"></i> <span>Collapse</span>
                        </button>
                      </div>
                      <button class="text-xs text-gray-400 hover:text-gray-300 px-2 py-0.5 bg-gray-800 rounded copy-json" onclick="event.preventDefault(); copyJsonToClipboard(this, '${jsonStr.replace(/'/g, "\\'")}'); return false;" title="Copy JSON">
                        <i class="fas fa-copy"></i> <span>Copy</span>
                      </button>
                    </div>
                    <div class="json-content text-xs font-mono">${formattedJson}</div>
                  </div>`);

                  if (suggestResult.success && suggestResult.suggested_url) {
                    // Read javascript_recommended and settle time from the API response
                    const jsRecommended = suggestResult.javascript_recommended === true;
                    const settleTime = suggestResult.javascript_settle_time_ms || 0;
                    
                    // Store the recommendations for later use in the crawl
                    window.javascriptRecommended = jsRecommended;
                    window.javascriptSettleTime = settleTime;
                    
                    if (jsRecommended) {
                      addLog(`JavaScript recommended for this URL.`);
                      if (settleTime > 0) {
                        addLog(`Recommended settle time: ${settleTime}ms for dynamic content loading.`);
                      }
                    }
                    
                    // Function to use URL in crawler input
                    const useUrlInCrawler = (url) => {
                      // Use React state instead of DOM manipulation for more reliable behavior
                      setInputValue(url);
                      setShowHistory(false);
                      
                      // Schedule a focus on the input field after state update
                      setTimeout(() => {
                        const inputField = document.querySelector('input[placeholder="Enter URL or summon phrase..."]');
                        if (inputField) {
                          inputField.focus();
                        }
                      }, 50);
                    };
                    
                    // Make this function accessible in window scope
                    window.useUrlInCrawler = useUrlInCrawler;
                    
                    // Removed redundant "Use this URL" link - it's already in the URL confirmation/translation section below
                    addLog(`<a href="#" class="text-green-400 hover:text-green-300 hover:underline ml-2" title="Use this URL" onclick="event.preventDefault(); event.stopPropagation(); window.useUrlInCrawler('${suggestResult.suggested_url.replace(/'/g, "\\'")}'); return false;"><i class="fas fa-level-up-alt mr-1"></i>Use this URL</a>`);
                    
                    // Only show the log if the URL actually changed
                    if (suggestResult.suggested_url !== queryUrl) {
                      addLog(`<div class="log-url-info"><span class="text-yellow-400 font-semibold">Translated to URL:</span> <span class="text-green-300">${suggestResult.suggested_url}</span> <a href="#" class="text-green-400 hover:text-green-300 hover:underline ml-2" title="Use this URL" onclick="event.preventDefault(); event.stopPropagation(); window.useUrlInCrawler('${suggestResult.suggested_url.replace(/'/g, "\\'")}'); return false;"><i class="fas fa-level-up-alt mr-1"></i>Use this URL</a></div>`);
                    } else {
                      addLog(`<div class="log-url-info"><span class="text-blue-400 font-semibold">URL confirmed:</span> <span class="text-green-300">${suggestResult.suggested_url}</span> <a href="#" class="text-green-400 hover:text-green-300 hover:underline ml-2" title="Use this URL" onclick="event.preventDefault(); event.stopPropagation(); window.useUrlInCrawler('${suggestResult.suggested_url.replace(/'/g, "\\'")}'); return false;"><i class="fas fa-level-up-alt mr-1"></i>Use this URL</a></div>`);
                    }
                    // Update the query to the suggested URL
                    queryUrl = suggestResult.suggested_url;
                    suggestSuccess = true;
                  } else {
                    addLog(`Suggestion API response received but no URL suggested.`);
                    // If URL wasn't suggested but input looks like a URL, keep it. Otherwise use default
                    // We no longer need to check for URL vs non-URL - all inputs are treated as URLs
                    suggestSuccess = true;
                  }

              } else {
                if (retryCount === maxRetries) {
                  // Create a visually distinctive error message
                  addLog(`<div class="bg-red-900 bg-opacity-30 border border-red-700 rounded px-3 py-2 my-2">
                    <div class="flex items-center">
                      <span class="text-red-500 mr-2"><i class="fas fa-exclamation-circle"></i></span>
                      <span class="text-red-400 font-semibold">API suggest failed (${suggestResponse.status})</span>
                    </div>
                    <div class="mt-1 text-red-300">
                      The URL suggestion service returned an error. Using original input: ${queryUrl}
                    </div>
                  </div>`);
                  // Don't use default URL fallback
                }
              }
            } catch (retryError) {
              if (retryCount === maxRetries) {
                // Create a visually distinctive error message for exceptions
                addLog(`<div class="bg-red-900 bg-opacity-30 border border-red-700 rounded px-3 py-2 my-2">
                  <div class="flex items-center">
                    <span class="text-red-500 mr-2"><i class="fas fa-exclamation-circle"></i></span>
                    <span class="text-red-400 font-semibold">API Error</span>
                  </div>
                  <div class="mt-1 text-red-300">
                    Error in suggestion API: ${retryError.message}<br>
                    Using original input: ${queryUrl}
                  </div>
                </div>`);
                // Do not force a default URL - keep original input
              }
            }
            
            retryCount++;
            
            // Break if success or if we've reached max retries
            if (suggestSuccess || retryCount > maxRetries) {
              break;
            }
            
            // Wait a short time before retrying
            await new Promise(resolve => setTimeout(resolve, 500));
          }
        } catch (suggestError) {
          // Create a visually distinctive error message for the main try/catch block
          addLog(`<div class="bg-red-900 bg-opacity-30 border border-red-700 rounded px-3 py-2 my-2">
            <div class="flex items-center">
              <span class="text-red-500 mr-2"><i class="fas fa-exclamation-circle"></i></span>
              <span class="text-red-400 font-semibold">API Connection Error</span>
            </div>
            <div class="mt-1 text-red-300">
              Failed to connect to suggestion API: ${suggestError.message}<br>
              Continuing with original input: ${queryUrl}
            </div>
          </div>`);
          // We no longer force a default URL
        }
        
        // Now make the actual crawl request
        addLog(`Crawling URL: ${queryUrl}${window.javascriptRecommended ? ' with JavaScript enabled' : ''}`);
        addLog('Scanning liminal boundaries...');
        
        const crawlResponse = await fetch('/api/crawl', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            url: queryUrl,
            title: `Minimal Crawl - ${queryUrl}`,
            take_screenshot: screenshotMode !== 'off',
            screenshot_mode: screenshotMode, // 'off', 'top', or 'full'
            javascript_enabled: forceJavascript || window.javascriptRecommended === true, // Force JS if enabled, otherwise use API recommendation
            javascript_settle_time: window.javascriptSettleTime || 0, // Use the settle time recommendation
            ocr_extraction: false,
            markdown_extraction: markdownQuality // 'enhanced', 'basic', or 'none'
          })
        });
        
        if (crawlResponse.ok) {
          const crawlResult = await crawlResponse.json();
          if (crawlResult.success) {
            // Log successful crawl
            addLog('Crawl successful.');
            
            if (crawlResult.report_path) {
              // Create correct report path based on the selected format
              let reportPath = '';
              let reportType = '';
              
              if (reportFormat === 'md') {
                // Ensure path starts with /reports/
                reportPath = crawlResult.report_path.startsWith('/reports/') 
                  ? crawlResult.report_path 
                  : `/reports/${crawlResult.report_path.split('/').pop()}`;
                reportType = 'Markdown';
              } else if (reportFormat === 'html') {
                // Ensure HTML path points to /reports/ and has .html extension
                const baseName = crawlResult.report_path.split('/').pop().replace('.md', '.html');
                reportPath = `/reports/${baseName}`;
                reportType = 'HTML';
              } else if (reportFormat === 'png') {
                // Extract screenshot from the first result
                if (crawlResult.results && crawlResult.results[0] && crawlResult.results[0].screenshot) {
                  // Ensure screenshot path starts with /screenshots/
                  const screenshotFile = crawlResult.results[0].screenshot.split('/').pop();
                  reportPath = `/screenshots/${screenshotFile}`;
                  reportType = 'Screenshot';
                } else {
                  // Fallback to markdown report in /reports/
                  reportPath = crawlResult.report_path.startsWith('/reports/') 
                    ? crawlResult.report_path 
                    : `/reports/${crawlResult.report_path.split('/').pop()}`;
                  reportType = 'Markdown';
                  addLog(`Screenshot not available, defaulting to Markdown.`);
                }
              }
              
              addLog(`<span class="text-blue-400 font-semibold">Report generated:</span> <span class="text-gray-300">${crawlResult.report_path}</span>`);
              
              if (reportType === 'HTML') {
                addLog(`<span class="text-teal-400 font-semibold">Materializing HTML report...</span>`);
              }
              
              addLog(`<div class="report-link bg-gray-900 rounded p-2 my-1 border-l-2 border-green-500">
                <div class="flex justify-between items-center">
                  <span class="text-xs text-green-400 font-semibold mr-2">View ${reportType} Report</span>
                  <a href="${reportPath}" target="_blank" class="text-green-300 hover:text-green-200 underline break-words px-2 py-1 bg-gray-800 rounded">
                    <i class="fas fa-external-link-alt text-xs mr-1"></i>Open ${reportType}
                  </a>
                </div>
              </div>`);
            }
            
            // Log success to server and update stats
            logToServer('crawl_success', { 
              query: queryUrl, 
              report_path: crawlResult.report_path || 'none',
              html_path: crawlResult.html_path || 'none'
            });
            
            // Update crawl stats for success
            updateCrawlStats(true);
          } else {
            addLog(`Crawl error: ${crawlResult.error || 'Unknown error'}`);
            logToServer('crawl_error', { query: queryUrl, error: crawlResult.error || 'Unknown error' });
            // Update crawl stats for error
            updateCrawlStats(false);
          }
        } else {
          addLog(`Server error: ${crawlResponse.status} - ${crawlResponse.statusText}`);
          logToServer('crawl_error', { query: queryUrl, error: `${crawlResponse.status} - ${crawlResponse.statusText}` });
          // Update crawl stats for error
          updateCrawlStats(false);
        }
      } catch (error) {
        addLog(`Error: ${error.message}`);
        logToServer('crawl_error', { query: queryUrl, error: error.message });
        // Update crawl stats for error
        updateCrawlStats(false);
      } finally {
        // Clear input regardless of success or failure
        setInputValue('');
      }
    }
  };

  const addLog = (message) => {
    // Ensure unique IDs even if logs are added in the same millisecond
    const uniqueId = Date.now() + Math.random().toString(36).substr(2, 5);
    
    // Check if the message already contains HTML
    const containsHtml = message.includes('<a') || message.includes('<span') || message.includes('<div');
    
    // If the message doesn't already contain HTML, check for URLs and make them clickable
    let processedMessage = message;
    if (!containsHtml) {
      // Regex to match URLs
      const urlRegex = /(https?:\/\/[^\s<>"']+)/g;
      processedMessage = message.replace(urlRegex, url => {
        // Skip if it's already in an HTML tag or looks like one
        if (url.includes('<') || url.includes('>')) return url;
        return `<a href="${url}" target="_blank" class="text-blue-400 hover:underline break-words">${url}</a>`;
      });
    }
    
    // Generate a formatted timestamp with microseconds in Z time
    const now = new Date();
    const pad = (num, size) => String(num).padStart(size, '0');
    const timestamp = `${now.getUTCFullYear()}-${pad(now.getUTCMonth() + 1, 2)}-${pad(now.getUTCDate(), 2)}T${pad(now.getUTCHours(), 2)}:${pad(now.getUTCMinutes(), 2)}:${pad(now.getUTCSeconds(), 2)}.${pad(now.getUTCMilliseconds(), 3)}Z`;
    
    // Subtle color change based on hour of day - create a gentle color cycle
    const hourFraction = (now.getHours() * 60 + now.getMinutes()) / (24 * 60);
    const hue = Math.floor(hourFraction * 360); // Full color cycle through the day
    const timestampColor = `hsl(${hue}, 85%, 65%)`; // Brighter, more pastel colors
    const timestampBgColor = `hsl(${hue}, 50%, 25%)`; // Lighter background with moderate saturation
    
    // Create an object with isHtml flag if the message contains HTML
    const logEntry = {
      id: uniqueId,
      message: processedMessage,
      timestamp,
      timestampColor,
      timestampBgColor,
      isHtml: containsHtml || processedMessage !== message // True if original contained HTML or we added HTML
    };
    
    setLogs(prevLogs => {
      // Keep only the last 100 logs for performance
      const newLogs = [...prevLogs, logEntry];
      return newLogs.slice(-100);
    });
  };
  
  // Function to update crawl statistics
  const updateCrawlStats = (success = true) => {
    setCrawlStats(prev => ({
      total: prev.total + 1,
      success: prev.success + (success ? 1 : 0),
      errors: prev.errors + (success ? 0 : 1)
    }));
    
    // Refresh recent reports when stats change
    fetchRecentReports();
  };

  const handleKeyPress = (e) => {
    if (e.key === 'Enter') {
      if (authStatus !== 'authorized') {
        handleAuthenticate();
      } else {
        handleSearch();
      }
      // Close history dropdown when Enter is pressed
      setShowHistory(false);
    } else if (e.key === 'Escape') {
      // Close history dropdown when Escape is pressed
      setShowHistory(false);
    }
  };

  // State for recent reports
  const [recentReports, setRecentReports] = useState([]);
  const [loadingRecentReports, setLoadingRecentReports] = useState(false);
  
  // Fetch recent reports when authorized
  useEffect(() => {
    if (authStatus === 'authorized') {
      fetchRecentReports();
    }
  }, [authStatus]);

  // Function to fetch recent reports (latest 5)
  const fetchRecentReports = async () => {
    try {
      setLoadingRecentReports(true);
      
      const response = await fetch('/reports?json=true');
      if (response.ok) {
        const data = await response.json();
        // Get only the 5 most recent reports
        const recent = (data.reports || []).slice(0, 5);
        setRecentReports(recent);
        console.log('Recent reports loaded:', recent.length);
      } else {
        console.error(`Failed to fetch recent reports: ${response.status}`);
        setRecentReports([]);
      }
    } catch (error) {
      console.error(`Error fetching recent reports: ${error.message}`);
      setRecentReports([]);
    } finally {
      setLoadingRecentReports(false);
    }
  };

    return (
        <div ref={rootContainerRef} className="h-screen bg-gray-900 text-green-400 p-4 font-mono overflow-hidden">

      <div className="w-full mx-auto flex flex-col h-full"> {/* Using flex-col to ensure proper layout */}
        <header className="mb-4">
          <div className="flex justify-between items-center">
            <h1 className="text-2xl md:text-3xl font-bold">GNOSIS WRAITH</h1>
            <div className="flex items-center space-x-2">
              <a href="https://github.com/kordless/gnosis-wraith/gnosis_wraith/server/templates/gnosis.html" target="_blank" className="px-3 py-1 bg-gray-800 hover:bg-gray-700 rounded text-xs">
                VERSION 3.2.7
              </a>
            </div>
          </div>
          <div className="flex items-center space-x-2 mt-2">
            <div className={`h-3 w-3 rounded-full ${
              systemStatus === 'online' ? 'bg-green-500' : 
              systemStatus === 'degraded' ? 'bg-yellow-500' :
              systemStatus === 'offline' ? 'bg-red-500' : 
              'bg-gray-500'
            }`}></div>
            <span className="text-sm uppercase">System Status: {systemStatus}</span>
                <div className="ml-auto text-xs text-gray-500">
                  Press <kbd className="px-1 py-0.5 bg-gray-800 rounded border border-gray-600">Enter</kbd> to crawl
                </div>

          </div>
        </header>

        {/* Crawler input box at top */}
        <div className="bg-gray-800 border border-gray-700 rounded-md p-4 mb-4">
          <div className="flex mb-2 border-b border-gray-700 justify-between items-center">
            <div className="flex">
              <button 
                className="px-4 py-2 border-b-2 border-green-500 text-green-400">
                <i className="fas fa-spider mr-2"></i>Crawler
              </button>
              <a 
                href="/forge"
                className="px-4 py-2 text-gray-400 hover:text-purple-400">
                <i className="fas fa-hammer mr-2"></i>Forge
              </a>
                                    <a 
                                        href="/vault" 
                                        className="px-4 py-2 text-gray-400 hover:text-blue-400">
                                        <i className="fas fa-archive mr-2"></i>Vault
                                    </a>
                                    <a 
                                        href="/about"
                                        className="px-4 py-2 text-gray-400 hover:text-orange-400">
                                        <i className="fas fa-info-circle mr-2"></i>About
                                    </a>

            </div>
            
            {authStatus === 'authorized' && (
              <div className="flex items-center space-x-4 text-xs text-gray-400">
                <div className="flex items-center space-x-1 bg-gray-900 p-1 rounded">
                  <label className={`cursor-pointer px-2 py-1 rounded ${reportFormat === 'md' ? 'bg-green-800 text-white' : ''}`}>
                    <input
                      type="radio"
                      name="reportFormat"
                      value="md"
                      checked={reportFormat === 'md'}
                      onChange={() => {
                        setReportFormat('md');
                        localStorage.setItem('gnosis_report_format', 'md');
                      }}
                      className="sr-only"
                    />
                    {reportFormat === 'md' && <i className="fas fa-file-alt mr-1"></i>}
                    MD
                  </label>
                  <label className={`cursor-pointer px-2 py-1 rounded ${reportFormat === 'html' ? 'bg-green-800 text-white' : ''}`}>
                    <input
                      type="radio"
                      name="reportFormat"
                      value="html"
                      checked={reportFormat === 'html'}
                      onChange={() => {
                        setReportFormat('html');
                        localStorage.setItem('gnosis_report_format', 'html');
                      }}
                      className="sr-only"
                    />
                    {reportFormat === 'html' && <i className="fas fa-code mr-1"></i>}
                    HTML
                  </label>
                  <label className={`cursor-pointer px-2 py-1 rounded ${reportFormat === 'png' && screenshotMode !== 'off' ? 'bg-green-800 text-white' : ''} ${screenshotMode === 'off' ? 'opacity-50 cursor-not-allowed' : ''}`}>
                    <input
                      type="radio"
                      name="reportFormat"
                      value="png"
                      checked={reportFormat === 'png'}
                      disabled={screenshotMode === 'off'}
                      onChange={() => {
                        if (screenshotMode !== 'off') {
                          setReportFormat('png');
                          localStorage.setItem('gnosis_report_format', 'png');
                        }
                      }}
                      className="sr-only"
                    />
                    {reportFormat === 'png' && screenshotMode !== 'off' && <i className="fas fa-image mr-1"></i>}
                    PNG
                  </label>
                </div>
                
                <div className="flex items-center space-x-1 bg-gray-900 p-1 rounded">
                  <label className={`cursor-pointer px-2 py-1 rounded ${screenshotMode === 'off' ? 'bg-red-800 text-white' : ''}`}>
                    <input
                      type="radio"
                      name="screenshotMode"
                      value="off"
                      checked={screenshotMode === 'off'}
                      onChange={() => {
                        setScreenshotMode('off');
                        localStorage.setItem('gnosis_screenshot_mode', 'off');
                        // Auto-switch to MD if PNG was selected
                        if (reportFormat === 'png') {
                          setReportFormat('md');
                          localStorage.setItem('gnosis_report_format', 'md');
                        }
                      }}
                      className="sr-only"
                    />
                    {screenshotMode === 'off' && <i className="fas fa-ban mr-1"></i>}
                    OFF
                  </label>
                  <label className={`cursor-pointer px-2 py-1 rounded ${screenshotMode === 'top' ? 'bg-blue-800 text-white' : ''}`}>
                    <input
                      type="radio"
                      name="screenshotMode"
                      value="top"
                      checked={screenshotMode === 'top'}
                      onChange={() => {
                        setScreenshotMode('top');
                        localStorage.setItem('gnosis_screenshot_mode', 'top');
                      }}
                      className="sr-only"
                    />
                    {screenshotMode === 'top' && <i className="fas fa-camera mr-1"></i>}
                    TOP
                  </label>
                  <label className={`cursor-pointer px-2 py-1 rounded ${screenshotMode === 'full' ? 'bg-green-800 text-white' : ''}`}>
                    <input
                      type="radio"
                      name="screenshotMode"
                      value="full"
                      checked={screenshotMode === 'full'}
                      onChange={() => {
                        setScreenshotMode('full');
                        localStorage.setItem('gnosis_screenshot_mode', 'full');
                      }}
                      className="sr-only"
                    />
                    {screenshotMode === 'full' && <i className="fas fa-camera mr-1"></i>}
                    FULL
                  </label>
                </div>
                
                <div className="flex items-center space-x-1 bg-gray-900 p-1 rounded">
                  <label className={`cursor-pointer px-2 py-1 rounded ${markdownQuality === 'enhanced' ? 'bg-green-800 text-white' : ''}`}>
                    <input
                      type="radio"
                      name="markdownQuality"
                      value="enhanced"
                      checked={markdownQuality === 'enhanced'}
                      onChange={() => {
                        setMarkdownQuality('enhanced');
                        localStorage.setItem('gnosis_markdown_quality', 'enhanced');
                      }}
                      className="sr-only"
                    />
                    {markdownQuality === 'enhanced' && <i className="fas fa-magic mr-1"></i>}
                    Enhanced
                  </label>
                  <label className={`cursor-pointer px-2 py-1 rounded ${markdownQuality === 'basic' ? 'bg-blue-800 text-white' : ''}`}>
                    <input
                      type="radio"
                      name="markdownQuality"
                      value="basic"
                      checked={markdownQuality === 'basic'}
                      onChange={() => {
                        setMarkdownQuality('basic');
                        localStorage.setItem('gnosis_markdown_quality', 'basic');
                      }}
                      className="sr-only"
                    />
                    {markdownQuality === 'basic' && <i className="fas fa-file-alt mr-1"></i>}
                    Basic
                  </label>
                  <label className={`cursor-pointer px-2 py-1 rounded ${markdownQuality === 'none' ? 'bg-gray-800 text-white' : ''}`}>
                    <input
                      type="radio"
                      name="markdownQuality"
                      value="none"
                      checked={markdownQuality === 'none'}
                      onChange={() => {
                        setMarkdownQuality('none');
                        localStorage.setItem('gnosis_markdown_quality', 'none');
                      }}
                      className="sr-only"
                    />
                    {markdownQuality === 'none' && <i className="fas fa-code mr-1"></i>}
                    Raw
                  </label>
                </div>
                
                <div className="flex items-center space-x-1 bg-gray-900 p-1 rounded">
                  <label className={`cursor-pointer px-2 py-1 rounded transition-colors ${forceJavascript ? 'bg-blue-800 text-white' : 'hover:bg-gray-700'}`}>
                    <input
                      type="checkbox"
                      checked={forceJavascript}
                      onChange={(e) => {
                        setForceJavascript(e.target.checked);
                        localStorage.setItem('gnosis_force_javascript', e.target.checked.toString());
                        addLog(`JavaScript force ${e.target.checked ? 'enabled' : 'disabled'}`);
                      }}
                      className="sr-only"
                    />
                    {forceJavascript && <i className="fab fa-js-square mr-1"></i>}
                    <i className={`fas ${forceJavascript ? 'fa-toggle-on' : 'fa-toggle-off'} mr-1`}></i>
                    Force
                  </label>
                </div>
              </div>
            )}
          </div>
          
          <div className="flex flex-col">
            <div className="flex flex-col space-y-2">
              <div className="flex space-x-2">
                <div className="relative flex-grow">
                  <input
                    type={authStatus === 'authorized' ? 'text' : 'password'}
                    placeholder={authStatus === 'authorized' ? "Enter URL or summon phrase..." : "Enter authentication key..."}
                    className="w-full px-3 py-2 bg-gray-900 border border-gray-700 rounded focus:outline-none focus:border-green-500"
                    value={inputValue}
                    onChange={handleInputChange}
                    onKeyPress={handleKeyPress}
                    onKeyDown={(e) => {
                      if (e.key === 'Escape') {
                        setShowHistory(false);
                      }
                    }}
                    onFocus={() => authStatus === 'authorized' && urlHistory.length > 0 && setShowHistory(true)}
                    onBlur={() => setTimeout(() => setShowHistory(false), 200)}
                  />
                {authStatus === 'authorized' && showHistory && urlHistory.length > 0 && (
                  <div className="absolute z-10 w-full mt-1 bg-gray-800 border border-gray-700 rounded shadow-lg">
                    <ul className="max-h-48 overflow-auto">
                      {urlHistory.map((url, index) => (
                        <li 
                          key={index}
                          className="px-3 py-2 text-sm hover:bg-gray-700 cursor-pointer truncate"
                          onClick={() => {
                            setInputValue(url);
                            setShowHistory(false);
                          }}
                        >
                          {url}
                        </li>
                      ))}
                    </ul>
                  </div>
                )}
              </div>
                <button
                  className="px-4 py-2 bg-green-800 hover:bg-green-700 text-white rounded"
                  onClick={authStatus === 'authorized' ? handleSearch : handleAuthenticate}
                >
                  {authStatus === 'authorized' ? 'Crawl' : 'Authenticate'}
                </button>
              </div>
            </div>
            
            {authStatus === 'authorized' && urlHistory.length > 0 && (
              <div className="mt-2 flex space-x-1 items-center">
                <span className="text-xs text-gray-500">Recent:</span>
                <div className="flex flex-wrap gap-1">
                  {urlHistory.slice(0, 3).map((url, index) => (
                    <button
                      key={index}
                      className="px-2 py-1 text-xs bg-gray-900 hover:bg-gray-700 rounded border border-gray-700"
                      onClick={() => setInputValue(url)}
                      title={url}
                    >
                      {url.length > 30 ? url.substring(0, 30) + '...' : url}
                    </button>
                  ))}
                  {urlHistory.length > 3 && (
                    <button
                      className="px-2 py-1 text-xs bg-gray-900 hover:bg-gray-700 rounded border border-gray-700"
                      onClick={() => setShowHistory(!showHistory)}
                    >
                      +{urlHistory.length - 3} more
                    </button>
                  )}
                    <button
                      className="px-2 py-1 text-xs bg-gray-900 hover:bg-gray-700 rounded border border-gray-700 text-red-400"
                      onClick={() => {
                        // Create confirmation modal
                        const confirmModal = document.createElement('div');
                        confirmModal.className = 'fixed inset-0 flex items-center justify-center bg-black bg-opacity-50 z-50';
                        confirmModal.innerHTML = `
                          <div class="bg-gray-800 border border-red-500 rounded-lg p-6 max-w-md w-full mx-4">
                            <div class="flex items-center mb-4">
                              <i class="fas fa-exclamation-triangle text-red-500 text-xl mr-3"></i>
                              <h3 class="text-lg font-semibold text-red-400">Clear Search History</h3>
                            </div>
                            <p class="text-gray-300 mb-6">
                              Are you sure you want to clear all URL search history? This action cannot be undone.
                            </p>
                            <div class="flex justify-end space-x-3">
                              <button class="px-4 py-2 bg-gray-700 hover:bg-gray-600 text-white rounded text-sm transition-colors" id="cancel-clear-btn">
                                Cancel
                              </button>
                              <button class="px-4 py-2 bg-red-700 hover:bg-red-600 text-white rounded text-sm transition-colors" id="confirm-clear-btn">
                                <i class="fas fa-trash mr-1"></i>Clear History
                              </button>
                            </div>
                          </div>
                        `;
                        document.body.appendChild(confirmModal);
                        
                        // Add event handlers
                        document.getElementById('cancel-clear-btn').addEventListener('click', () => {
                          document.body.removeChild(confirmModal);
                        });
                        
                        document.getElementById('confirm-clear-btn').addEventListener('click', () => {
                          localStorage.removeItem('gnosis_url_history');
                          setUrlHistory([]);
                          addLog('URL history has been cleared');
                          document.body.removeChild(confirmModal);
                        });
                        
                        // Close modal when clicking outside
                        confirmModal.addEventListener('click', (e) => {
                          if (e.target === confirmModal) {
                            document.body.removeChild(confirmModal);
                          }
                        });
                        
                        // Handle escape key
                        const handleEscape = (e) => {
                          if (e.key === 'Escape') {
                            document.body.removeChild(confirmModal);
                            document.removeEventListener('keydown', handleEscape);
                          }
                        };
                        document.addEventListener('keydown', handleEscape);
                      }}
                      title="Clear URL history"
                    >
                      <span className="text-red-400">Ã—</span> Clear
                    </button>

                </div>
              </div>
            )}
          </div>
        </div>

        <div 
          className="flex flex-col md:flex-row gap-4 mb-4 flex-grow" 
          style={{ 
            minHeight: '180px'
            // Height will be managed dynamically by our resize handler
          }}>
          <div className="flex-grow">
            <div 
              ref={logContainerRef} 
              className="bg-gray-800 border border-gray-700 rounded-md overflow-auto log-container crt-scanlines crt-flicker"
              style={{ visibility: logContainerVisible ? 'visible' : 'hidden' }}
            >

              <div className="px-4 py-2 border-b border-gray-700 bg-gray-900">
                <h2 className="text-lg font-semibold text-green-400">Logs</h2>
              </div>
              <div className="p-4">
              {logs.map(log => (
                <div key={log.id} className="mb-2 break-words overflow-wrap-anywhere text-sm">
                  <div className="flex">
                    <div 
                      className="flex-shrink-0 px-2 py-0.5 rounded-md mr-2 font-mono text-xs flex items-center justify-center" 
                      style={{ 
                        color: log.timestampColor || '#9ca3af', 
                        backgroundColor: log.timestampBgColor || 'rgba(31, 41, 55, 0.5)',
                        minHeight: '1.75rem' // Ensure consistent height
                      }}
                    >
                      {log.timestamp}
                    </div>
                    
                    <div className="flex-grow flex items-center"> {/* Message content aligned with timestamp */}
                      {log.isHtml ? (
                        <span dangerouslySetInnerHTML={{ __html: log.message }} className="break-words" />
                      ) : (
                        <span className="break-words overflow-wrap-anywhere">{log.message}</span>
                      )}
                    </div>
                  </div>
                </div>
              ))}
              {logs.length === 0 && (
                <div className="h-full flex items-center justify-center text-gray-600">
                  Initializing system...
                </div>
              )}
              <div ref={logsEndRef} />
              </div>
            </div>
          </div>
          
          <div className="space-y-4 md:w-1/4 flex-shrink-0">
                            <div className="bg-gray-800 border border-gray-700 rounded-md p-4">
              <h2 className="text-xl mb-3">System Controls</h2>
              <div className="space-y-2">
                <div className={`${authStatus === 'authorized' ? 'text-green-500' : 'text-yellow-500'}`}>
                  Status: {authStatus === 'authorized' ? 'AUTHORIZED' : 'UNAUTHORIZED'}
                </div>
                
                {authStatus === 'authorized' && (
                  <>
                    <div className="border-t border-gray-700 my-2 pt-2">
                      <div className="text-green-400 font-semibold">Crawl Statistics</div>
                    </div>

                    <div className="grid grid-cols-3 gap-2 text-center text-sm">
                      <div className="bg-gray-900 rounded p-1">
                        <div className="text-gray-400">Total</div>
                        <div className="text-xl">{crawlStats.total}</div>
                      </div>
                      <div className="bg-gray-900 rounded p-1">
                        <div className="text-gray-400">Success</div>
                        <div className="text-xl text-green-500">{crawlStats.success}</div>
                      </div>
                      <div className="bg-gray-900 rounded p-1">
                        <div className="text-gray-400">Errors</div>
                        <div className="text-xl text-red-500">{crawlStats.errors}</div>
                      </div>
                    </div>
                    
                    {crawlStats.lastUrl && (
                      <div className="mt-2 text-xs bg-gray-900 rounded p-2 border border-gray-700">
                        <div className="text-gray-400 mb-1">Last Crawled:</div>
                        <div className="truncate text-green-300" title={crawlStats.lastUrl}>
                          {crawlStats.lastUrl}
                        </div>
                      </div>
                    )}
                    
                    <button 
                      className="w-full mt-2 bg-gray-900 hover:bg-gray-700 text-xs border border-gray-700 rounded p-1"
                      onClick={() => {
                        if (confirm('Are you sure you want to clear all crawl statistics?')) {
                          setCrawlStats({ total: 0, success: 0, errors: 0 });
                          localStorage.removeItem('gnosis_crawl_stats');
                          addLog('Crawl statistics have been reset');
                        }
                      }}
                    >
                      Reset Stats
                    </button>
                    
                    <div className="border-t border-gray-700 my-2 pt-2">
                      <div className="text-green-400 font-semibold mb-2">System Uptime</div>
                      {(() => {
                        const errorRate = crawlStats.total > 0 ? (crawlStats.errors / crawlStats.total) * 100 : 0;
                        const successRate = 100 - errorRate;
                        const uptimeColor = successRate >= 95 ? 'bg-green-500' : 
                                          successRate >= 80 ? 'bg-yellow-500' : 'bg-red-500';
                        
                        return (
                          <div>
                            <div className="flex justify-between text-xs mb-1">
                              <span>Success Rate</span>
                              <span>{successRate.toFixed(1)}%</span>
                            </div>
                            <div className="w-full bg-gray-700 rounded-full h-2 mb-2">
                              <div 
                                className={`h-2 rounded-full transition-all duration-300 ${uptimeColor}`}
                                style={{ width: `${successRate}%` }}
                              ></div>
                            </div>
                            <div className="text-xs text-gray-400">
                              {crawlStats.total > 0 ? 
                                `Error Rate: ${errorRate.toFixed(1)}% (${crawlStats.errors}/${crawlStats.total})` :
                                'No crawls recorded yet'
                              }
                            </div>
                          </div>
                        );
                      })()}
                    </div>
                    
                    <div className="mt-3 border-t border-gray-700 pt-3">
                      <div className="text-green-400 font-semibold mb-2">LLM Settings</div>
                      
                      {/* Provider selection dropdown */}
                      <div className="text-xs text-gray-400 mb-1">LLM Provider:</div>
                      <div className="mb-2">
                        <select 
                          className="w-full px-2 py-1 bg-gray-900 border border-gray-700 rounded text-xs"
                          value={localStorage.getItem('gnosis_wraith_llm_provider') || 'anthropic'}
                          onChange={(e) => {
                            // Save the selected provider
                            localStorage.setItem('gnosis_wraith_llm_provider', e.target.value);
                            addLog(`Provider set to ${e.target.value}`);
                            
                            // Force re-render to update the key input field
                            setCrawlStats({...crawlStats});
                          }}
                        >
                          <option value="anthropic">Anthropic (Claude)</option>
                          <option value="openai">OpenAI (GPT)</option>
                          <option value="gemini">Google (Gemini)</option>
                        </select>
                      </div>
                      
                      {/* API Key input field that adapts based on selected provider */}
                      {(() => {
                        // Get current provider
                        const provider = localStorage.getItem('gnosis_wraith_llm_provider') || 'anthropic';
                        
                        // Key name and placeholder based on provider
                        let keyName, placeholder, cookieName;
                        
                        switch(provider) {
                          case 'anthropic':
                            keyName = 'Anthropic API Token';
                            placeholder = 'sk-ant-api...';
                            cookieName = 'gnosis_wraith_llm_token_anthropic';
                            break;
                          case 'openai':
                            keyName = 'OpenAI API Token';
                            placeholder = 'sk-...';
                            cookieName = 'gnosis_wraith_llm_token_openai';
                            break;
                          case 'gemini':
                            keyName = 'Google Gemini API Token';
                            placeholder = 'api_key...';
                            cookieName = 'gnosis_wraith_llm_token_gemini';
                            break;
                          default:
                            keyName = 'API Token';
                            placeholder = 'Enter API token';
                            cookieName = 'gnosis_wraith_llm_token_anthropic';
                        }
                        
                        // Function to get the cookie
                        const getCookie = (name) => {
                          const nameEQ = `${name}=`;
                          const ca = document.cookie.split(';');
                          for (let i = 0; i < ca.length; i++) {
                            let c = ca[i];
                            while (c.charAt(0) === ' ') c = c.substring(1);
                            if (c.indexOf(nameEQ) === 0) {
                              return c.substring(nameEQ.length, c.length);
                            }
                          }
                          return '';
                        };
                        
                        // Function to set the cookie
                        const setCookie = (name, value, days = 90) => {
                          const date = new Date();
                          date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000));
                          const expires = `expires=${date.toUTCString()}`;
                          document.cookie = `${name}=${value};${expires};path=/;SameSite=Strict`;
                        };
                        
                        // Function to delete the cookie
                        const deleteCookie = (name) => {
                          document.cookie = `${name}=;expires=Thu, 01 Jan 1970 00:00:00 UTC;path=/;`;
                        };
                        
                        // Get the current API key from the cookie
                        const currentKey = getCookie(cookieName);
                        
                        return (
                          <>
                            <div className="text-xs text-gray-400 mb-1">{keyName}:</div>
                            <div className="flex space-x-1">
                              <input 
                                type="password"
                                className="flex-grow px-2 py-1 bg-gray-900 border border-gray-700 rounded text-xs cursor-pointer"
                                placeholder={currentKey ? "â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢" : "Click 'Set' to configure"}
                                value={currentKey ? "â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢" : ""}
                                readOnly={true}
                                onClick={() => {
                                  // Click the Set/Clear button when field is clicked
                                  const button = document.querySelector(`button:contains("${currentKey ? 'Clear' : 'Set'}")`);
                                  if (button) button.click();
                                }}
                                                                                title="Click 'Set' button to configure API token"

                              />
                              <button
                                className="px-2 py-1 bg-gray-700 hover:bg-gray-600 rounded text-xs"
                                onClick={() => {
                                  // If we have a key, confirm deletion
                                  if (currentKey) {
                                    // Create an inline modal for confirmation
                                    const confirmBox = document.createElement('div');
                                    confirmBox.className = 'fixed inset-0 flex items-center justify-center bg-black bg-opacity-50 z-50';
                                    confirmBox.innerHTML = `
                                      <div class="bg-gray-800 border border-gray-700 rounded-md p-4 max-w-md w-full">
                                        <div class="text-green-400 font-semibold mb-2">Confirm</div>
                                        <div class="text-white mb-4">Are you sure you want to remove this API key?</div>
                                        <div class="flex justify-end space-x-2">
                                          <button class="px-3 py-1 bg-gray-700 hover:bg-gray-600 text-white rounded text-sm" id="cancel-btn">Cancel</button>
                                          <button class="px-3 py-1 bg-red-700 hover:bg-red-600 text-white rounded text-sm" id="confirm-btn">Remove</button>
                                        </div>
                                      </div>
                                    `;
                                    document.body.appendChild(confirmBox);
                                    
                                    // Add event handlers
                                    document.getElementById('cancel-btn').addEventListener('click', () => {
                                      document.body.removeChild(confirmBox);
                                    });
                                    document.getElementById('confirm-btn').addEventListener('click', () => {
                                      deleteCookie(cookieName);
                                      addLog(`${keyName} removed`);
                                      document.body.removeChild(confirmBox);
                                      // Force re-render by updating state
                                      setCrawlStats({...crawlStats});
                                    });
                                  } else {
                                    // Create an inline modal for entering a new key
                                    const inputBox = document.createElement('div');
                                    inputBox.className = 'fixed inset-0 flex items-center justify-center bg-black bg-opacity-50 z-50';
                                    inputBox.innerHTML = `
                                      <div class="bg-gray-800 border border-gray-700 rounded-md p-4 max-w-md w-full">
                                        <div class="text-green-400 font-semibold mb-2">Enter ${keyName}</div>
                                        <input type="text" id="api-key-input" class="w-full px-3 py-2 bg-gray-900 border border-gray-700 rounded mb-4" placeholder="${placeholder}"/>
                                        <div class="flex justify-end space-x-2">
                                          <button class="px-3 py-1 bg-gray-700 hover:bg-gray-600 text-white rounded text-sm" id="cancel-key-btn">Cancel</button>
                                          <button class="px-3 py-1 bg-green-700 hover:bg-green-600 text-white rounded text-sm" id="save-key-btn">Save</button>
                                        </div>
                                      </div>
                                    `;
                                    document.body.appendChild(inputBox);
                                    
                                    // Focus the input field
                                    setTimeout(() => {
                                      document.getElementById('api-key-input').focus();
                                    }, 100);
                                    
                                    // Add event handlers
                                    document.getElementById('cancel-key-btn').addEventListener('click', () => {
                                      document.body.removeChild(inputBox);
                                    });
                                    document.getElementById('save-key-btn').addEventListener('click', () => {
                                      const inputEl = document.getElementById('api-key-input');
                                      const newKey = inputEl.value.trim();
                                      
                                      if (newKey) {
                                        setCookie(cookieName, newKey);
                                        addLog(`${keyName} saved`);
                                        document.body.removeChild(inputBox);
                                        // Force re-render by updating state
                                        setCrawlStats({...crawlStats});
                                      } else {
                                        // Highlight input with red border if empty
                                        inputEl.classList.add('border-red-500');
                                        setTimeout(() => {
                                          inputEl.classList.remove('border-red-500');
                                        }, 2000);
                                      }
                                    });
                                    
                                    // Handle enter key
                                    document.getElementById('api-key-input').addEventListener('keydown', (e) => {
                                      if (e.key === 'Enter') {
                                        document.getElementById('save-key-btn').click();
                                      } else if (e.key === 'Escape') {
                                        document.getElementById('cancel-key-btn').click();
                                      }
                                    });
                                  }
                                }}
                              >
                                {currentKey ? 'Clear' : 'Set'}
                              </button>
                            </div>
                          </>
                        );
                      })()}
                      
                      {/* Security info */}
                      <div className="mt-2 text-xs text-gray-500 italic">
                        API tokens are stored locally in cookies with SameSite=Strict
                      </div>
                    </div>
                    
                    <button 
                      className="w-full mt-3 bg-gray-900 hover:bg-gray-700 text-xs border border-gray-700 rounded p-1"
                      onClick={() => {
                        // Create a nice modal for logout confirmation
                        const logoutModal = document.createElement('div');
                        logoutModal.className = 'fixed inset-0 flex items-center justify-center bg-black bg-opacity-50 z-50';
                        logoutModal.innerHTML = `
                          <div class="bg-gray-800 border border-red-500 rounded-lg p-6 max-w-md w-full mx-4">
                            <div class="flex items-center mb-4">
                              <i class="fas fa-exclamation-triangle text-red-500 text-xl mr-3"></i>
                              <h3 class="text-lg font-semibold text-red-400">WIPE SYSTEM</h3>
                            </div>
                            <p class="text-gray-300 mb-4">
                              Choose your logout method:
                            </p>
                            <div class="space-y-3 mb-6">
                              <div class="bg-gray-900 border border-gray-700 rounded p-3">
                                <div class="font-semibold text-yellow-400 mb-1">Standard Logout</div>
                                <div class="text-sm text-gray-400">Clear authentication only. Keep LLM tokens and settings.</div>
                              </div>
                              <div class="bg-gray-900 border border-red-700 rounded p-3">
                                <div class="font-semibold text-red-400 mb-1">WIPE ALL DATA</div>
                                <div class="text-sm text-gray-400">Clear authentication AND all stored tokens/cookies.</div>
                              </div>
                            </div>
                            <div class="flex justify-end space-x-3">
                              <button class="px-4 py-2 bg-gray-700 hover:bg-gray-600 text-white rounded text-sm transition-colors" id="cancel-logout-btn">
                                Cancel
                              </button>
                              <button class="px-4 py-2 bg-yellow-700 hover:bg-yellow-600 text-white rounded text-sm transition-colors" id="standard-logout-btn">
                                <i class="fas fa-sign-out-alt mr-1"></i>Standard Logout
                              </button>
                              <button class="px-4 py-2 bg-red-700 hover:bg-red-600 text-white rounded text-sm transition-colors" id="wipe-system-btn">
                                <i class="fas fa-trash mr-1"></i>WIPE SYSTEM
                              </button>
                            </div>
                          </div>
                        `;
                        document.body.appendChild(logoutModal);
                        
                        // Add event handlers
                        document.getElementById('cancel-logout-btn').addEventListener('click', () => {
                          document.body.removeChild(logoutModal);
                        });
                        
                        document.getElementById('standard-logout-btn').addEventListener('click', () => {
                          localStorage.removeItem('gnosis_auth_code');
                          setAuthStatus('unauthorized');
                          addLog('Authentication cleared');
                          addLog('System locked');
                          addLog('Awaiting new authentication...');
                          document.body.removeChild(logoutModal);
                        });
                        
                        document.getElementById('wipe-system-btn').addEventListener('click', () => {
                          // Clear all localStorage
                          localStorage.clear();
                          
                          // Clear all cookies
                          document.cookie.split(";").forEach(function(c) { 
                            document.cookie = c.replace(/^ +/, "").replace(/=.*/, "=;expires=" + new Date().toUTCString() + ";path=/"); 
                          });
                          
                          setAuthStatus('unauthorized');
                          addLog('SYSTEM WIPED - All data cleared');
                          addLog('Authentication cleared');
                          addLog('All tokens and cookies removed');
                          addLog('System reset complete');
                          addLog('Awaiting new authentication...');
                          document.body.removeChild(logoutModal);
                        });
                        
                        // Close modal when clicking outside
                        logoutModal.addEventListener('click', (e) => {
                          if (e.target === logoutModal) {
                            document.body.removeChild(logoutModal);
                          }
                        });
                        
                        // Handle escape key
                        const handleEscape = (e) => {
                          if (e.key === 'Escape') {
                            document.body.removeChild(logoutModal);
                            document.removeEventListener('keydown', handleEscape);
                          }
                        };
                        document.addEventListener('keydown', handleEscape);
                      }}
                    >
                      Log Out
                    </button>
                  </>
                )}
              </div>
            </div>
            
            {authStatus === 'authorized' && (
              <>
                <div className="bg-gray-800 border border-gray-700 rounded-md p-4">
                  <h3 className="text-lg mb-2">Recent Crawls</h3>
                  {recentReports.length > 0 ? (
                    <ul className="text-sm space-y-2">
                      {recentReports.map(report => (
                        <li key={report.filename} className="border-b border-gray-700 pb-1 last:border-b-0">
                          <a 
                            href={report.filename.startsWith('/') ? report.filename : `/reports/${report.filename}`} 
                            target="_blank" 
                            className="text-green-300 hover:underline truncate block"
                          >
                            {report.title}
                          </a>
                          <div className="text-xs text-gray-400">
                            {report.created_str}
                          </div>
                        </li>
                      ))}
                    </ul>
                  ) : loadingRecentReports ? (
                    <div className="text-center py-2">
                      <div className="text-xs text-gray-400">Loading...</div>
                    </div>
                  ) : (
                    <div className="text-gray-500 text-sm">No recent crawls found</div>
                  )}
                </div>
                
                {/* System Resources and Liminal Access boxes removed */}
              </>
            )}
          </div>
        </div>

        {/* This div is now empty since we moved its content to the top */}
      </div>
    </div>
  );
};
        
        // Function to format JSON with syntax highlighting and better word wrapping
        const formatJsonForDisplay = (jsonString) => {
          try {
            // First, parse and re-stringify the JSON to ensure proper format
            const obj = typeof jsonString === 'string' ? JSON.parse(jsonString) : jsonString;
            
            // Replace JSON syntax with HTML spans for syntax highlighting
            return JSON.stringify(obj, null, 2)
              .replace(/&/g, '&amp;')
              .replace(/</g, '&lt;')
              .replace(/>/g, '&gt;')
              .replace(/("(\\u[a-zA-Z0-9]{4}|\\[^u]|[^\\"])*"(\s*:)?|\b(true|false|null)\b|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?)/g, 
                function (match) {
                  let cls = 'text-blue-400'; // Default for numbers
                  
                  if (/^"/.test(match)) {
                    if (/:$/.test(match)) {
                      cls = 'text-purple-400 font-semibold'; // Keys
                    } else {
                      cls = 'text-green-400'; // Strings
                    }
                  } else if (/true|false/.test(match)) {
                    cls = 'text-yellow-500'; // Booleans
                  } else if (/null/.test(match)) {
                    cls = 'text-red-400'; // null values
                  }
                  
                  return '<span class="' + cls + '">' + match + '</span>';
                });
          } catch (e) {
            console.error("Error formatting JSON:", e);
            return jsonString; // Return the original string if there's an error
          }
        };
        
        // Function to copy JSON to clipboard
        window.copyJsonToClipboard = function(button, jsonString) {
          // Create test modal first to verify function is being called
          const testModal = document.createElement('div');
          testModal.className = 'fixed inset-0 flex items-center justify-center bg-black bg-opacity-50 z-50';
          testModal.innerHTML = `
            <div class="bg-gray-800 border border-gray-700 rounded-lg p-6 max-w-md w-full mx-4">
              <div class="flex items-center mb-4">
                <i class="fas fa-clipboard text-blue-500 text-xl mr-3"></i>
                <h3 class="text-lg font-semibold text-blue-400">Copy JSON Debug</h3>
              </div>
              <div class="text-gray-300 mb-4">
                <p class="mb-2">Function called successfully!</p>
                <p class="text-sm">JSON length: ${jsonString ? jsonString.length : 'null'} characters</p>
                <p class="text-sm">Clipboard API available: ${navigator.clipboard ? 'Yes' : 'No'}</p>
                <p class="text-sm">Secure context: ${window.isSecureContext ? 'Yes' : 'No'}</p>
              </div>
              <div class="bg-gray-900 rounded p-3 mb-4 max-h-32 overflow-auto">
                <div class="text-xs font-mono text-green-400">JSON Preview:</div>
                <div class="text-xs font-mono text-gray-300 mt-1">${jsonString ? jsonString.substring(0, 200) + (jsonString.length > 200 ? '...' : '') : 'No JSON data'}</div>
              </div>
              <div class="flex justify-end space-x-3">
                <button class="px-4 py-2 bg-gray-700 hover:bg-gray-600 text-white rounded text-sm" id="test-cancel-btn">
                  Cancel
                </button>
                <button class="px-4 py-2 bg-blue-700 hover:bg-blue-600 text-white rounded text-sm" id="test-copy-btn">
                  Try Copy Now
                </button>
              </div>
            </div>
          `;
          document.body.appendChild(testModal);
          
          // Add event handlers
          document.getElementById('test-cancel-btn').addEventListener('click', () => {
            document.body.removeChild(testModal);
          });
          
          document.getElementById('test-copy-btn').addEventListener('click', () => {
            // Now actually try to copy
            try {
              if (navigator.clipboard && window.isSecureContext) {
                navigator.clipboard.writeText(jsonString).then(() => {
                  // Success feedback
                  const originalText = button.querySelector('span').textContent;
                  const originalIcon = button.querySelector('i').className;
                  
                  button.querySelector('span').textContent = 'Copied!';
                  button.querySelector('i').className = 'fas fa-check';
                  button.style.backgroundColor = 'rgba(34, 197, 94, 0.3)';
                  
                  setTimeout(() => {
                    button.querySelector('span').textContent = originalText;
                    button.querySelector('i').className = originalIcon;
                    button.style.backgroundColor = '';
                  }, 2000);
                  
                  document.body.removeChild(testModal);
                }).catch(err => {
                  console.error('Clipboard API failed:', err);
                  fallbackCopyTextToClipboard(jsonString, button);
                  document.body.removeChild(testModal);
                });
              } else {
                fallbackCopyTextToClipboard(jsonString, button);
                document.body.removeChild(testModal);
              }
            } catch (error) {
              console.error('Error in copy function:', error);
              fallbackCopyTextToClipboard(jsonString, button);
              document.body.removeChild(testModal);
            }
          });
          
          // Close modal when clicking outside
          testModal.addEventListener('click', (e) => {
            if (e.target === testModal) {
              document.body.removeChild(testModal);
            }
          });
        };
        
        // Fallback function for copying text to clipboard
        function fallbackCopyTextToClipboard(text, button) {
          try {
            const textArea = document.createElement('textarea');
            textArea.value = text;
            textArea.style.position = 'fixed';
            textArea.style.left = '-999999px';
            textArea.style.top = '-999999px';
            document.body.appendChild(textArea);
            textArea.focus();
            textArea.select();
            
            const successful = document.execCommand('copy');
            document.body.removeChild(textArea);
            
            if (successful) {
              // Provide visual feedback
              const originalText = button.querySelector('span').textContent;
              const originalIcon = button.querySelector('i').className;
              
              button.querySelector('span').textContent = 'Copied!';
              button.querySelector('i').className = 'fas fa-check';
              button.style.backgroundColor = 'rgba(34, 197, 94, 0.3)';
              
              setTimeout(() => {
                button.querySelector('span').textContent = originalText;
                button.querySelector('i').className = originalIcon;
                button.style.backgroundColor = '';
              }, 2000);
            } else {
              throw new Error('Copy command failed');
            }
          } catch (err) {
            console.error('Fallback copy failed:', err);
            // Show error feedback
            const originalText = button.querySelector('span').textContent;
            const originalIcon = button.querySelector('i').className;
            
            button.querySelector('span').textContent = 'Failed';
            button.querySelector('i').className = 'fas fa-exclamation-triangle';
            button.style.backgroundColor = 'rgba(239, 68, 68, 0.3)';
            
            setTimeout(() => {
              button.querySelector('span').textContent = originalText;
              button.querySelector('i').className = originalIcon;
              button.style.backgroundColor = '';
            }, 2000);
          }
        }
        
        // Function to toggle JSON visibility (for collapsible sections)
        window.toggleJsonVisibility = function(button) {
          const container = button.closest('.json-container');
          const content = container.querySelector('.json-content');
          const buttonText = button.querySelector('span');
          const icon = button.querySelector('i');
          
          if (content.style.display === 'none') {
            // Show the content
            content.style.display = 'block';
            buttonText.textContent = 'Collapse';
            icon.className = 'fas fa-chevron-down';
          } else {
            // Hide the content
            content.style.display = 'none';
            buttonText.textContent = 'Expand';
            icon.className = 'fas fa-chevron-right';
          }
        };

        // Function to copy JSON to clipboard
        window.copyJsonToClipboard = function(button, jsonString) {
          try {
            // Use the modern clipboard API if available
            if (navigator.clipboard && window.isSecureContext) {
              navigator.clipboard.writeText(jsonString).then(() => {
                showCopySuccess(button);
              }).catch(err => {
                console.error('Failed to copy to clipboard:', err);
                fallbackCopy(jsonString, button);
              });
            } else {
              // Fallback for older browsers or non-HTTPS
              fallbackCopy(jsonString, button);
            }
          } catch (error) {
            console.error('Copy error:', error);
            fallbackCopy(jsonString, button);
          }
        };

        // Fallback copy method using textarea
        function fallbackCopy(text, button) {
          const textArea = document.createElement('textarea');
          textArea.value = text;
          textArea.style.position = 'fixed';
          textArea.style.left = '-999999px';
          textArea.style.top = '-999999px';
          document.body.appendChild(textArea);
          textArea.focus();
          textArea.select();
          
          try {
            const successful = document.execCommand('copy');
            if (successful) {
              showCopySuccess(button);
            } else {
              showCopyError(button);
            }
          } catch (err) {
            console.error('Fallback copy failed:', err);
            showCopyError(button);
          } finally {
            document.body.removeChild(textArea);
          }
        }

        // Show copy success feedback
        function showCopySuccess(button) {
          const originalContent = button.innerHTML;
          button.innerHTML = '<i class="fas fa-check text-green-400"></i> <span>Copied!</span>';
          button.classList.add('text-green-400');
          
          setTimeout(() => {
            button.innerHTML = originalContent;
            button.classList.remove('text-green-400');
          }, 2000);
        }

        // Show copy error feedback
        function showCopyError(button) {
          const originalContent = button.innerHTML;
          button.innerHTML = '<i class="fas fa-exclamation-triangle text-red-400"></i> <span>Failed</span>';
          button.classList.add('text-red-400');
          
          setTimeout(() => {
            button.innerHTML = originalContent;
            button.classList.remove('text-red-400');
          }, 2000);
        }

        // Find the component function name from the code
        const scriptContent = document.querySelector('script[type="text/babel"]').textContent;
        const functionMatch = scriptContent.match(/function\s+(\w+)/);
        const constMatch = scriptContent.match(/const\s+(\w+)\s*=/);
        
        let componentName = null;
        if (functionMatch) {
            componentName = functionMatch[1];
        } else if (constMatch) {
            componentName = constMatch[1];
        }
        
        // Render the component
        if (componentName && typeof window[componentName] === 'function') {
            const root = ReactDOM.createRoot(document.getElementById('root'));
            root.render(React.createElement(window[componentName]));
        } else {
            // Fallback - try to find any function in the window object that looks like a React component
            const possibleComponents = Object.keys(window).filter(key => 
                typeof window[key] === 'function' && 
                window[key].toString().includes('React.createElement')
            );
            
            if (possibleComponents.length > 0) {
                const root = ReactDOM.createRoot(document.getElementById('root'));
                root.render(React.createElement(window[possibleComponents[0]]));
            } else {
                document.getElementById('root').innerHTML = 
                    '<div class="p-8 text-red-600 text-center"><h2 class="text-xl font-bold mb-2">Error</h2><p>Could not find a React component to render.</p></div>';
            }
        }
        {% endraw %}
    </script>
</body>
</html>
