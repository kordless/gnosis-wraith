import os
import datetime
import logging
import aiofiles
import markdown
from typing import List, Dict, Any

# Get logger from config
logger = logging.getLogger("gnosis_wraith")
REPORTS_DIR = os.environ.get('GNOSIS_WRAITH_REPORTS_DIR', os.path.join(os.path.expanduser("~"), ".gnosis-wraith/reports"))

def generate_markdown_report(title: str, crawl_results: List[Dict[str, Any]]) -> str:
    """Generate a markdown report from crawl results, including LLM summaries if available."""
    md = f"# {title}\n\n"
    md += f"*Generated on {datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')}*\n\n"
    
    # Add executive summary if available in results
    if any('llm_summary' in result for result in crawl_results):
        md += f"## Executive Summary\n\n"
        md += f"*This summary was generated by AI based on the collected content*\n\n"
        
        # Try to find an overall summary if one was generated
        overall_summary = next((result.get('overall_summary') for result in crawl_results if 'overall_summary' in result), None)
        if overall_summary:
            md += f"{overall_summary}\n\n"
        else:
            # Create a simple summary listing the pages analyzed
            md += f"This report contains analysis of {len(crawl_results)} URLs:\n\n"
            for result in crawl_results:
                if 'error' not in result:
                    md += f"- {result.get('title', 'Untitled Page')}: {result['url']}\n"
            md += "\n"
        
        md += "---\n\n"
    
    for i, result in enumerate(crawl_results, 1):
        md += f"## {i}. {result.get('title', 'Untitled Page')}\n\n"
        md += f"**URL**: {result['url']}\n\n"
        
        # Add JavaScript setting information
        js_enabled = result.get('javascript_enabled', False)
        md += f"**JavaScript**: {'Enabled' if js_enabled else 'Disabled'}\n\n"
        
        if 'error' in result:
            md += f"**Error**: {result['error']}\n\n"
        else:
            # Add screenshot as image - use relative path
            if 'screenshot' in result:
                logger.info(f"Adding screenshot to report: {result['screenshot']}")
                try:
                    relative_path = os.path.relpath(result['screenshot'], REPORTS_DIR)
                    md += f"**Screenshot**:\n\n"
                    md += f"![Screenshot of {result['url']}]({relative_path})\n\n"
                except Exception as e:
                    logger.error(f"Error adding screenshot to report: {str(e)}")
                    md += f"**Screenshot**: Error including screenshot: {str(e)}\n\n"
            
            # Add LLM summary if available
            if 'llm_summary' in result:
                md += f"**AI Summary**:\n\n"
                md += f"{result['llm_summary']}\n\n"
            
            # Add LLM error if there was an issue with AI processing
            if 'llm_error' in result:
                md += f"**AI Processing Error**:\n\n"
                md += f"```\n{result['llm_error']}\n```\n\n"
            
            # Add extracted text
            if 'extracted_text' in result:
                md += f"**Extracted Text**:\n\n"
                md += f"```\n{result['extracted_text']}\n```\n\n"
        
        md += "---\n\n"
    
    # Add metadata section with information about the processing
    md += f"## Metadata\n\n"
    md += f"- **Total URLs Processed**: {len(crawl_results)}\n"
    
    # Include information about the LLM provider used if available
    llm_provider = next((result.get('llm_provider') for result in crawl_results if 'llm_provider' in result), None)
    if llm_provider:
        md += f"- **AI Provider**: {llm_provider}\n"
    
    md += f"- **Generated By**: Gnosis Wraith\n"
    
    return md

async def save_markdown_report(title: str, crawl_results: List[Dict[str, Any]]) -> str:
    """Save a markdown report to disk and return the file path."""
    report_content = generate_markdown_report(title, crawl_results)

    import string
    valid_chars = string.ascii_letters + string.digits + '-_'
    safe_title = ''.join(c if c in valid_chars else '_' for c in title)
    filename = f"{safe_title}_{datetime.datetime.now().strftime('%Y%m%d_%H%M%S')}.md"

    report_path = os.path.join(REPORTS_DIR, filename)
    
    async with aiofiles.open(report_path, 'w') as f:
        await f.write(report_content)
    
    return report_path

async def convert_markdown_to_html(markdown_file: str) -> str:
    """Convert a markdown file to HTML with enhanced styling for AI summaries."""
    html_file = f"{os.path.splitext(markdown_file)[0]}.html"
    
    async with aiofiles.open(markdown_file, 'r') as f:
        md_content = await f.read()
    
    # Check for image references and make sure they're valid
    import re
    image_refs = re.findall(r'!\[(.*?)\]\((.*?)\)', md_content)
    for alt_text, image_path in image_refs:
        logger.info(f"Found image reference in markdown: {alt_text} at path {image_path}")
        
        # Check if the image path exists or needs fixing
        if not os.path.isabs(image_path):
            # Try to resolve relative to the REPORTS_DIR
            potential_path = os.path.join(os.path.dirname(markdown_file), image_path)
            if os.path.exists(potential_path):
                logger.info(f"Image path is valid: {potential_path}")
            else:
                logger.warning(f"Image path may be invalid: {potential_path}")
    
    # Add extensions for better markdown rendering
    html = markdown.markdown(md_content, extensions=['tables', 'fenced_code', 'codehilite'])
    
    styled_html = f"""<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{os.path.basename(markdown_file)}</title>
    <style>
        :root {{
            --primary-color: #4e9eff;
            --bg-color: #1e2129;
            --card-bg: #282c34;
            --text-color: #e2e2e2;
            --border-color: #3a3f4b;
            --ai-summary-bg: rgba(78, 158, 255, 0.1);
            --ai-summary-border: rgba(78, 158, 255, 0.3);
        }}
        
        body {{ 
            font-family: 'Menlo', 'Monaco', 'Courier New', monospace;
            line-height: 1.6; 
            max-width: 900px; 
            margin: 0 auto; 
            padding: 20px;
            background-color: var(--bg-color);
            color: var(--text-color);
        }}
        
        img {{ max-width: 100%; border-radius: 4px; box-shadow: 0 4px 8px rgba(0,0,0,0.3); }}
        
        code {{ 
            background-color: rgba(0,0,0,0.2); 
            padding: 2px 5px; 
            border-radius: 3px;
        }}
        
        pre {{ 
            background-color: var(--card-bg); 
            padding: 15px; 
            border-radius: 4px;
            overflow-x: auto; 
            border: 1px solid var(--border-color);
        }}
        
        h1, h2, h3 {{ color: var(--primary-color); }}
        
        h2 {{ 
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 10px;
        }}
        
        /* Style AI summary sections */
        h3:contains('AI Summary') + p {{
            background-color: var(--ai-summary-bg);
            border: 1px solid var(--ai-summary-border);
            border-radius: 4px;
            padding: 15px;
            margin-top: 5px;
        }}
        
        hr {{
            border: none;
            border-top: 1px solid var(--border-color);
            margin: 30px 0;
        }}
    </style>
</head>
<body>
    {html}
</body>
</html>"""
    
    async with aiofiles.open(html_file, 'w') as f:
        await f.write(styled_html)
    
    return html_file