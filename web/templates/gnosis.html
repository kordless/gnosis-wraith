
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gnosis Wraith | Minimal Interface</title>
    
    <!-- React and ReactDOM -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.development.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.development.js"></script>
    
    <!-- Babel for JSX -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.21.2/babel.min.js"></script>
    <!-- NOTE FOR PRODUCTION: Replace the above with precompiled JSX for production environments -->
    
    <!-- Tailwind CSS - Using specific version with production mode to avoid warnings -->
    <script src="https://cdn.tailwindcss.com?plugins=forms,typography,aspect-ratio"></script>
    <script>
      tailwind.config = {
        mode: 'jit',
        darkMode: 'class',
        theme: {
          extend: {
            colors: {
              'terminal-green': '#4ade80',
            }
          }
        }
      }
    </script>
    
    <!-- Font Awesome -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    
    <!-- Custom styles for word wrapping -->
    <style>
        /* Custom CSS for word wrapping long URLs */
        .break-words {
            word-wrap: break-word;
            word-break: break-word;
            overflow-wrap: break-word;
            -ms-word-break: break-all;
            -ms-hyphens: auto;
            -moz-hyphens: auto;
            -webkit-hyphens: auto;
            hyphens: auto;
        }
        .overflow-wrap-anywhere {
            overflow-wrap: anywhere;
        }
        
        /* JSON display styling */
        .json-container {
            position: relative;
            margin: 4px 0;
            transition: all 0.2s ease;
        }
        .json-container:hover {
            box-shadow: 0 0 10px rgba(108, 99, 255, 0.2);
        }
        .json-content {
            white-space: pre-wrap !important;  /* Important to override any inline styles */
            word-break: break-all !important;  /* Force break anywhere needed */
            overflow-wrap: break-word !important;
            word-wrap: break-word !important;  /* For IE/Edge */
            padding: 6px;
            line-height: 1.4;
            max-width: 100%;
        }
        .json-content span {
            word-break: break-all !important; /* Break even within words if needed */
            overflow-wrap: anywhere !important; /* Modern browsers */
            display: inline-block !important; /* Allow long strings to wrap */
            max-width: 100% !important;
            white-space: pre-wrap !important; /* Allow wrapping */
        }
        /* Special handling for URLs and other long strings */
        .json-content .text-green-400 {
            word-break: break-all !important;
            max-width: calc(100% - 10px) !important;
        }
        .toggle-json {
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .toggle-json:hover {
            background-color: rgba(108, 99, 255, 0.2) !important;
        }
        
        /* URL and report info styling */
        .log-url-info {
            margin: 4px 0;
            padding: 4px 6px;
            border-radius: 4px;
            background-color: rgba(50, 50, 70, 0.3);
        }
        .report-link {
            transition: all 0.2s ease;
        }
        .report-link:hover {
            box-shadow: 0 0 10px rgba(72, 187, 120, 0.3);
        }
        /* Ensure the body and html fill the entire viewport with dark background */
        html, body {
            height: 100vh;
            background-color: #111827; /* bg-gray-900 equivalent */
            margin: 0;
            padding: 0;
            overflow: hidden;
        }
        /* Allow scrolling within containers but fit content in viewport */
        body {
            height: 100vh;
        }
        /* Ensure containers with overflow can scroll */
        .log-container {
            overflow-y: auto !important;
            position: relative;
        }
        
        /* CRT Scan Lines Effect */
        .crt-scanlines::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: repeating-linear-gradient(
                0deg,
                transparent,
                transparent 2px,
                rgba(0, 255, 0, 0.03) 2px,
                rgba(0, 255, 0, 0.03) 4px
            );
            pointer-events: none;
            z-index: 1;
        }
        
        /* CRT Flicker Animation */
        .crt-flicker {
            animation: flicker 0.15s infinite linear;
        }
        
        @keyframes flicker {
            0% { opacity: 1; }
            98% { opacity: 1; }
            99% { opacity: 0.98; }
            100% { opacity: 1; }
        }
        
        /* Random flicker trigger */
        .crt-flicker.active {
            animation: flicker-strong 0.1s ease-in-out;
        }
        
        @keyframes flicker-strong {
            0% { opacity: 1; }
            50% { opacity: 0.8; }
            100% { opacity: 1; }
        }
        
        /* CRT Glow Effect */
        .crt-glow {
            text-shadow: 0 0 5px #00ff00, 0 0 10px #00ff00, 0 0 15px #00ff00;
        }
    </style>
</head>
<body class="bg-gray-900 p-0 m-0">
    <div id="root"></div>
    
    <script type="text/babel">
        {% raw %}
        // React hooks are globally available
        const { useState, useEffect, useRef } = React;
        
        const GnosisWraithInterface = () => {
  const [authStatus, setAuthStatus] = useState('unauthorized');
  const [inputValue, setInputValue] = useState('');
  const [systemStatus, setSystemStatus] = useState('initializing');
  const [healthCheckInterval, setHealthCheckInterval] = useState(null);
  const [logs, setLogs] = useState([]);
  const [crawlStats, setCrawlStats] = useState({
    total: 0,
    success: 0,
    errors: 0,
    lastUrl: ''
  });
  const [urlHistory, setUrlHistory] = useState([]);
  const [showHistory, setShowHistory] = useState(false);
  const [reportFormat, setReportFormat] = useState('md'); // Default to Markdown
  const [forceJavascript, setForceJavascript] = useState(false); // Force JavaScript toggle
  const [screenshotMode, setScreenshotMode] = useState('full'); // Default to full screenshots
  const [markdownQuality, setMarkdownQuality] = useState('enhanced'); // Default to enhanced markdown
  const logsEndRef = useRef(null);
  
  // Use localStorage to persist settings
  useEffect(() => {
    // Check if a valid auth code exists in localStorage or cookies
    let storedAuthCode = localStorage.getItem('gnosis_auth_code');
    
    // If not in localStorage, check cookies
    if (!storedAuthCode) {
      const getCookie = (name) => {
        const nameEQ = `${name}=`;
        const ca = document.cookie.split(';');
        for (let i = 0; i < ca.length; i++) {
          let c = ca[i];
          while (c.charAt(0) === ' ') c = c.substring(1);
          if (c.indexOf(nameEQ) === 0) {
            return c.substring(nameEQ.length, c.length);
          }
        }
        return '';
      };
      storedAuthCode = getCookie('gnosis_auth_code');
    }
    
    if (storedAuthCode && /^c0d3z\d{4}$/i.test(storedAuthCode)) {
      // Auto-authenticate if valid code exists
      setAuthStatus('authorized');
    }
    
    // Load URL history from localStorage
    try {
      const storedHistory = localStorage.getItem('gnosis_url_history');
      if (storedHistory) {
        setUrlHistory(JSON.parse(storedHistory));
      }
    } catch (e) {
      console.error('Error loading URL history:', e);
    }
    
    // Load report format preference from localStorage
    try {
      const storedFormat = localStorage.getItem('gnosis_report_format');
      if (storedFormat && ['md', 'html', 'png'].includes(storedFormat)) {
        setReportFormat(storedFormat);
      }
    } catch (e) {
      console.error('Error loading report format preference:', e);
    }
    
    // Load force JavaScript preference from localStorage
    try {
      const storedForceJs = localStorage.getItem('gnosis_force_javascript');
      if (storedForceJs === 'true') {
        setForceJavascript(true);
      }
    } catch (e) {
      console.error('Error loading force JavaScript preference:', e);
    }
    
    // Load screenshot mode preference from localStorage
    try {
      const storedScreenshotMode = localStorage.getItem('gnosis_screenshot_mode');
      if (storedScreenshotMode && ['off', 'top', 'full'].includes(storedScreenshotMode)) {
        setScreenshotMode(storedScreenshotMode);
      }
    } catch (e) {
      console.error('Error loading screenshot mode preference:', e);
    }
    
    // Load markdown quality preference from localStorage
    try {
      const storedMarkdownQuality = localStorage.getItem('gnosis_markdown_quality');
      if (storedMarkdownQuality && ['enhanced', 'basic', 'none'].includes(storedMarkdownQuality)) {
        setMarkdownQuality(storedMarkdownQuality);
      }
    } catch (e) {
      console.error('Error loading markdown quality preference:', e);
    }
    
    // Set log container visibility to true by default
    setLogContainerVisible(true);
    
    // Start health checking immediately
    checkServerHealth();
    
    // Set up periodic health checks every 30 seconds
    const interval = setInterval(checkServerHealth, 30000);
    setHealthCheckInterval(interval);
    
    // Simulate system initialization
    setTimeout(() => {
      addLog('System initialization complete');
      addLog('Gnosis Wraith v3.2.7 ready');
      
      // Check localStorage directly instead of relying on authStatus state
      const storedAuthCode = localStorage.getItem('gnosis_auth_code');
      if (storedAuthCode && /^c0d3z\d{4}$/i.test(storedAuthCode)) {
        addLog('Authentication found in local storage');
        addLog('Distributed crawler system online');
        addLog('Memory banks accessible');
      } else {
        addLog('Awaiting authentication...');
        addLog('Required format: c0d3zXXXX where XXXX is a 4-digit number');
      }
      
      // Load stored crawl stats if they exist
      const storedStats = localStorage.getItem('gnosis_crawl_stats');
      if (storedStats) {
        try {
          const stats = JSON.parse(storedStats);
          // Ensure we have the lastUrl property
          if (!stats.hasOwnProperty('lastUrl')) {
            stats.lastUrl = '';
          }
          setCrawlStats(stats);
          addLog(`Loaded previous session statistics: ${stats.total} crawls`);
        } catch (e) {
          console.error('Error parsing stored crawl stats:', e);
        }
      }
    }, 1500);
    
    // Cleanup interval on unmount
    return () => {
      if (interval) {
        clearInterval(interval);
      }
    };
  }, []);
  
  // Update local storage when crawl stats change
  useEffect(() => {
    // Skip initial render
    if (crawlStats.total > 0) {
      localStorage.setItem('gnosis_crawl_stats', JSON.stringify(crawlStats));
    }
  }, [crawlStats]);
  
  // Store URL history in local storage
  const updateUrlHistory = (url) => {
    // Get existing history or initialize empty array
    let history = [];
    try {
      const storedHistory = localStorage.getItem('gnosis_url_history');
      if (storedHistory) {
        history = JSON.parse(storedHistory);
      }
    } catch (e) {
      console.error('Error parsing URL history:', e);
    }
    
    // Add new URL to history if not a duplicate of the most recent
    if (url && url.trim() && (history.length === 0 || history[0] !== url)) {
      history.unshift(url); // Add to beginning
      history = history.slice(0, 10); // Keep only 10 most recent
      localStorage.setItem('gnosis_url_history', JSON.stringify(history));
    }
    
    return history;
  };
  
  // State to track user scrolling and auto-scrolling settings
  const [isUserScrolling, setIsUserScrolling] = useState(false);
  const [shouldScrollToBottom, setShouldScrollToBottom] = useState(true);
  
  // Auto-scroll logs to bottom when new logs are added or when container becomes visible
  useEffect(() => {
    // Only scroll if there are logs and the log container is visible
    if (logs.length > 0 && 
        logsEndRef && logsEndRef.current && 
        logContainerVisible && 
        !isUserScrolling && 
        shouldScrollToBottom) {
      
      // Only attempt to scroll if we have valid refs
      if (logsEndRef && logsEndRef.current) {
        // Scroll to bottom smoothly
        logsEndRef.current.scrollIntoView({ behavior: 'smooth' });
      }
    }
  }, [logs, logContainerVisible, isUserScrolling, shouldScrollToBottom]);
  
  // Handle scroll events in the log container to detect position
  useEffect(() => {
    const handleScroll = () => {
      if (logContainerRef && logContainerRef.current) {
        const container = logContainerRef.current;
        // Calculate if we're near the bottom
        const isNearBottom = container.scrollHeight - container.scrollTop - container.clientHeight < 100;
        
        // Update auto-scroll flag based on scroll position
        setShouldScrollToBottom(isNearBottom);
      }
    };
    
    // Add scroll event listener to the log container
    const logContainer = logContainerRef && logContainerRef.current ? logContainerRef.current : null;
    if (logContainer) {
      logContainer.addEventListener('scroll', handleScroll);
    }
    
    return () => {
      // Clean up event listener
      if (logContainer) {
        logContainer.removeEventListener('scroll', handleScroll);
      }
    };
  }, []); // Empty dependency array, this only runs on mount and unmount
  
  // Handle mouse down/up to detect when user is actively scrolling
  useEffect(() => {
    const handleMouseDown = () => {
      setIsUserScrolling(true);
    };
    
    const handleMouseUp = () => {
      setIsUserScrolling(false);
      
      // If user releases mouse while near bottom, scroll to bottom immediately
      if (shouldScrollToBottom && 
          logContainerRef && logContainerRef.current && 
          logsEndRef && logsEndRef.current) {
        logsEndRef.current.scrollIntoView({ behavior: 'smooth' });
      }
    };
    
    // Add event listeners to the document
    document.addEventListener('mousedown', handleMouseDown);
    document.addEventListener('mouseup', handleMouseUp);
    
    return () => {
      // Clean up event listeners
      document.removeEventListener('mousedown', handleMouseDown);
      document.removeEventListener('mouseup', handleMouseUp);
    };
  }, [shouldScrollToBottom]);
  
  // CRT flicker effect
  useEffect(() => {
    const flickerInterval = setInterval(() => {
      if (Math.random() < 0.1) { // 10% chance every interval
        const crtElement = logContainerRef.current;
        if (crtElement) {
          crtElement.classList.add('active');
          setTimeout(() => {
            crtElement.classList.remove('active');
          }, 100);
        }
      }
    }, 2000);
    
    return () => clearInterval(flickerInterval);
  }, []);
  
  // Create references
  const logContainerRef = useRef(null);
  const rootContainerRef = useRef(null);
  
  // State to track log container visibility
  const [logContainerVisible, setLogContainerVisible] = useState(false);
  
  // Simple height calculation that fills available space
  useEffect(() => {
    const calculateHeight = () => {
      if (logContainerRef.current && rootContainerRef.current) {
        const viewportHeight = window.innerHeight;
        const logContainer = logContainerRef.current;
        const logRect = logContainer.getBoundingClientRect();
        
        // Calculate available height from current position to bottom of viewport
        const availableHeight = viewportHeight - logRect.top - 20; // 20px bottom margin
        
        // Set minimum height
        const finalHeight = Math.max(300, availableHeight);
        
        // Apply the height
        logContainer.style.height = `${finalHeight}px`;
        logContainer.style.visibility = 'visible';
        setLogContainerVisible(true);
      }
    };
    
    // Initial calculation
    const timer = setTimeout(calculateHeight, 100);
    
    // Handle window resize
    const handleResize = () => {
      calculateHeight();
    };
    
    window.addEventListener('resize', handleResize);
    
    return () => {
      clearTimeout(timer);
      window.removeEventListener('resize', handleResize);
    };
  }, []); // Run once on mount

  const handleInputChange = (e) => {
    setInputValue(e.target.value);
  };

  // Helper function to get cookie value
  const getCookie = (name) => {
    const nameEQ = `${name}=`;
    const ca = document.cookie.split(';');
    for (let i = 0; i < ca.length; i++) {
      let c = ca[i];
      while (c.charAt(0) === ' ') c = c.substring(1);
      if (c.indexOf(nameEQ) === 0) {
        return c.substring(nameEQ.length, c.length);
      }
    }
    return '';
  };

  const handleAuthenticate = () => {
    if (inputValue.trim()) {
      setAuthStatus('authenticating');
      addLog(`Authentication attempt: ${inputValue.substring(0, 3)}${'*'.repeat(inputValue.length - 3)}`);
      
      // Check if input is a valid code
      const codePattern = /^c0d3z\d{4}$/i;
      if (codePattern.test(inputValue)) {
        setTimeout(() => {
          // Check if this is a different code than what's currently stored
          const currentStoredCode = localStorage.getItem('gnosis_auth_code') || getCookie('gnosis_auth_code');
          
          if (currentStoredCode && currentStoredCode !== inputValue) {
            // Different code - clear all existing data first
            addLog(`New authentication code detected`);
            addLog(`Clearing previous session data for security`);
            
            // Clear all localStorage except the new auth code we're about to set
            localStorage.clear();
            
            // Clear all cookies
            document.cookie.split(";").forEach(function(c) { 
              document.cookie = c.replace(/^ +/, "").replace(/=.*/, "=;expires=" + new Date().toUTCString() + ";path=/"); 
            });
            
            addLog(`Previous session data cleared`);
          }
          
          setAuthStatus('authorized');
          addLog('Authentication successful');
          addLog(`Access code verified: ${inputValue}`);
          addLog('Distributed crawler system online');
          addLog('Memory banks accessible');
          setInputValue('');
          
          // Store the new auth code in both localStorage and cookies
          localStorage.setItem('gnosis_auth_code', inputValue);
          
          // Also store in cookie with 90 day expiration
          const date = new Date();
          date.setTime(date.getTime() + (90 * 24 * 60 * 60 * 1000));
          const expires = `expires=${date.toUTCString()}`;
          document.cookie = `gnosis_auth_code=${inputValue};${expires};path=/;SameSite=Strict`;
          
          // Log successful auth to server (optional)
          logToServer('authentication', { code: inputValue });
        }, 1000);
      } else if (inputValue.toLowerCase() === 'password') {
        // Legacy password for testing
        setTimeout(() => {
          setAuthStatus('authorized');
          addLog('Legacy authentication successful');
          addLog('Distributed crawler system online');
          addLog('Memory banks accessible');
          addLog('WARNING: Using legacy credentials');
          setInputValue('');
        }, 1000);
      } else {
        // Failed authentication
        setTimeout(() => {
          setAuthStatus('unauthorized');
          addLog('Authentication failed');
          addLog('Access denied: Invalid code format');
          addLog('Required format: c0d3zXXXX where XXXX is a 4-digit number');
          setInputValue('');
        }, 1000);
      }
    }
  };

  // Function to check server health
  const checkServerHealth = async () => {
    try {
      const response = await fetch('/health', {
        method: 'HEAD',
        cache: 'no-cache'
      });
      
      if (response.ok) {
        if (systemStatus !== 'online') {
          setSystemStatus('online');
          console.log('\ud83d\udfe2 Health Check: Server is ONLINE (HEAD /health returned 200)');
        }
      } else {
        if (systemStatus !== 'degraded') {
          setSystemStatus('degraded');
          const statusExplanation = getHttpStatusExplanation(response.status);
          console.log(`\ud83d\udfe1 Health Check: Server is DEGRADED (HEAD /health returned ${response.status} - ${statusExplanation})`);
          addLog(`Server health check failed: HTTP ${response.status} - ${statusExplanation}`);
        }
      }
    } catch (error) {
      if (systemStatus !== 'offline') {
        setSystemStatus('offline');
        console.log(`\ud83d\udd34 Health Check: Server is OFFLINE (HEAD /health failed - ${error.message})`);
        addLog(`Server health check failed: ${error.message}`);
      }
    }
  };
  
  // Function to explain HTTP status codes
  const getHttpStatusExplanation = (status) => {
    const statusCodes = {
      400: 'Bad Request',
      401: 'Unauthorized', 
      403: 'Forbidden',
      404: 'Not Found (health endpoint missing)',
      405: 'Method Not Allowed',
      408: 'Request Timeout',
      500: 'Internal Server Error',
      502: 'Bad Gateway',
      503: 'Service Unavailable',
      504: 'Gateway Timeout'
    };
    
    return statusCodes[status] || `HTTP ${status}`;
  };

  // Function to log events to server
  const logToServer = async (eventType, data) => {
    try {
      // Add timestamp to all log entries
      const logData = {
        ...data,
        timestamp: new Date().toISOString(),
        event: eventType
      };
      
      // Log the event to the client console for debugging
      console.log(`Logging to server: ${eventType}`, logData);
      
      // Send the log to server (this would be implemented on the server)
      const response = await fetch('/api/log', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(logData)
      });
      
      // Only add the log to the UI if the server request was successful
      if (response.ok) {
        addLog(`Event logged: ${eventType}`);
      }
    } catch (error) {
      // Silent fail if logging fails - doesn't affect the user experience
      console.error('Error logging to server:', error);
    }
  };

  // URL validation function
  const isValidUrl = (urlString) => {
    // Enhanced URL validation that catches most valid URLs
    if (urlString.startsWith('http://') || urlString.startsWith('https://')) {
      return true;
    }
    
    // Check for domain-like patterns without protocol
    // This regex matches patterns like: example.com, sub.example.co.uk, etc.
    const domainPattern = /^[a-z0-9]+([\-\.]{1}[a-z0-9]+)*\.[a-z]{2,}$/i;
    if (domainPattern.test(urlString)) {
      return true;
    }
    
    return false;
  };

  // Function to perform the actual crawl with a given URL
  const performCrawl = async (urlToCrawl, isRetry = false) => {
    addLog(`${isRetry ? 'Retrying crawl' : 'Crawling URL'}: ${urlToCrawl}${window.javascriptRecommended ? ' with JavaScript enabled' : ''}`);
    if (!isRetry) {
      addLog('Scanning liminal boundaries...');
    }
    
    try {
      const crawlResponse = await fetch('/api/crawl', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          url: urlToCrawl,
          title: `Minimal Crawl - ${urlToCrawl}`,
          take_screenshot: screenshotMode !== 'off',
          screenshot_mode: screenshotMode, // 'off', 'top', or 'full'
          javascript_enabled: forceJavascript || window.javascriptRecommended === true, // Force JS if enabled, otherwise use API recommendation
          javascript_settle_time: window.javascriptSettleTime || 0, // Use the settle time recommendation
          ocr_extraction: false,
          markdown_extraction: markdownQuality // 'enhanced', 'basic', or 'none'
        })
      });
      
      if (crawlResponse.ok) {
        const crawlResult = await crawlResponse.json();
        if (crawlResult.success) {
          // Log successful crawl
          addLog('Crawl successful.');
          
          if (crawlResult.report_path) {
            // Create correct report path based on the selected format
            let reportPath = '';
            let reportType = '';
            
            if (reportFormat === 'md') {
              // Ensure path starts with /reports/
              reportPath = crawlResult.report_path.startsWith('/reports/') 
                ? crawlResult.report_path 
                : `/reports/${crawlResult.report_path.split('/').pop()}`;
              reportType = 'Markdown';
            } else if (reportFormat === 'html') {
              // Ensure HTML path points to /reports/ and has .html extension
              const baseName = crawlResult.report_path.split('/').pop().replace('.md', '.html');
              reportPath = `/reports/${baseName}`;
              reportType = 'HTML';
            } else if (reportFormat === 'png') {
              // Extract screenshot from the first result
              if (crawlResult.results && crawlResult.results[0] && crawlResult.results[0].screenshot) {
                // Ensure screenshot path starts with /screenshots/
                const screenshotFile = crawlResult.results[0].screenshot.split('/').pop();
                reportPath = `/screenshots/${screenshotFile}`;
                reportType = 'Screenshot';
              } else {
                // Fallback to markdown report in /reports/
                reportPath = crawlResult.report_path.startsWith('/reports/') 
                  ? crawlResult.report_path 
                  : `/reports/${crawlResult.report_path.split('/').pop()}`;
                reportType = 'Markdown';
                addLog(`Screenshot not available, defaulting to Markdown.`);
              }
            }
            
            addLog(`<span class="text-blue-400 font-semibold">Report generated:</span> <span class="text-gray-300">${crawlResult.report_path}</span>`);
            
            if (reportType === 'HTML') {
              addLog(`<span class="text-teal-400 font-semibold">Materializing HTML report...</span>`);
            }
            
            addLog(`<div class="report-link bg-gray-900 rounded p-2 my-1 border-l-2 border-green-500">
              <div class="flex justify-between items-center">
                <span class="text-xs text-green-400 font-semibold mr-2">View ${reportType} Report</span>
                <a href="${reportPath}" target="_blank" class="text-green-300 hover:text-green-200 underline break-words px-2 py-1 bg-gray-800 rounded">
                  <i class="fas fa-external-link-alt text-xs mr-1"></i>Open ${reportType}
                </a>
              </div>
            </div>`);
          }
          
          // Log success to server and update stats
          logToServer('crawl_success', { 
            query: urlToCrawl, 
            report_path: crawlResult.report_path || 'none',
            html_path: crawlResult.html_path || 'none'
          });
          
          // Update crawl stats for success
          updateCrawlStats(true);
          return true; // Indicate success
        } else {
          addLog(`Crawl error: ${crawlResult.error || 'Unknown error'}`);
          logToServer('crawl_error', { query: urlToCrawl, error: crawlResult.error || 'Unknown error' });
          // Update crawl stats for error
          updateCrawlStats(false);
          return false; // Indicate failure
        }
      } else {
        addLog(`Server error: ${crawlResponse.status} - ${crawlResponse.statusText}`);
        logToServer('crawl_error', { query: urlToCrawl, error: `${crawlResponse.status} - ${crawlResponse.statusText}` });
        // Update crawl stats for error
        updateCrawlStats(false);
        return false; // Indicate failure
      }
    } catch (error) {
      addLog(`Error: ${error.message}`);
      logToServer('crawl_error', { query: urlToCrawl, error: error.message });
      // Update crawl stats for error
      updateCrawlStats(false);
      return false; // Indicate failure
    }
  };

  const handleSearch = async () => {
    if (inputValue.trim()) {
      // Store the query or URL
      let queryUrl = inputValue.trim();
      
      // Add to URL history and update state
      const updatedHistory = updateUrlHistory(queryUrl);
      setUrlHistory(updatedHistory);
      
      // Update last URL in stats
      setCrawlStats(prev => ({
        ...prev,
        lastUrl: queryUrl
      }));
      
      addLog(`Initiating crawl sequence for: ${queryUrl}`);
      
      try {
        // Check if it looks like a valid URL
        let isUrl = isValidUrl(queryUrl);
        
        // If it's a domain without protocol, add https://
        if (isUrl && !queryUrl.startsWith('http://') && !queryUrl.startsWith('https://')) {
          queryUrl = 'https://' + queryUrl;
          addLog(`Added protocol: ${queryUrl}`);
        }
        
        // Log crawl attempt to server
        logToServer('crawl_attempt', { 
          query: queryUrl,
          auth_code: localStorage.getItem('gnosis_auth_code') || 'none'
        });
        
        let crawlSuccess = false;
        
        // If it looks like a URL, try crawling directly first
        if (isUrl) {
          addLog(`URL detected, attempting direct crawl...`);
          window.javascriptRecommended = false; // Reset recommendation for direct crawl
          window.javascriptSettleTime = 0;
          
          // Try direct crawl
          crawlSuccess = await performCrawl(queryUrl);
          
          // If direct crawl failed, use suggestion API as fallback
          if (!crawlSuccess) {
            addLog(`Direct crawl failed, trying URL suggestion service...`);
          }
        } else {
          addLog(`Text query detected, using suggestion service...`);
        }
        
        // If direct crawl failed or it's not a URL, use suggestion API
        if (!isUrl || !crawlSuccess) {
          addLog('Dispatching ethereal agents...');
          
          // Use the suggestion API
          try {
            // Get the selected provider and corresponding API key from cookies
            const provider = localStorage.getItem('gnosis_wraith_llm_provider') || 'anthropic';
            
            // Get the API key for the selected provider
            let apiKey = '';
            let cookieName = '';
            
            switch(provider) {
              case 'anthropic':
                cookieName = 'gnosis_wraith_llm_token_anthropic';
                break;
              case 'openai':
                cookieName = 'gnosis_wraith_llm_token_openai';
                break;
              case 'gemini':
                cookieName = 'gnosis_wraith_llm_token_gemini';
                break;
              default:
                cookieName = 'gnosis_wraith_llm_token_anthropic';
            }
            
            apiKey = getCookie(cookieName);
            
            // Log the request before making it
            addLog(`<div class="api-request px-2 py-1 bg-gray-900 rounded border-l-2 border-blue-500 inline-block">
              <span class="text-blue-400 font-mono font-semibold">POST</span>
              <span class="text-gray-400 font-mono">/api/suggest</span>
              <span class="text-yellow-400 font-mono ml-2 px-1.5 py-0.5 bg-yellow-900 bg-opacity-30 rounded">SENDING</span>
            </div>`);
            
            const suggestResponse = await fetch('/api/suggest', {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json'
              },
              body: JSON.stringify({ 
                query: queryUrl,
                provider: provider,
                api_key: apiKey || null // Send the user's API key if available
              })
            });
            
            // Log the response status immediately after receiving it
            const statusColor = suggestResponse.ok ? 'text-green-400' : 'text-red-400';
            const statusBg = suggestResponse.ok ? 'bg-green-900' : 'bg-red-900';
            addLog(`<div class="api-request px-2 py-1 bg-gray-900 rounded border-l-2 border-blue-500 inline-block">
              <span class="text-blue-400 font-mono font-semibold">POST</span>
              <span class="text-gray-400 font-mono">/api/suggest</span>
              <span class="${statusColor} font-mono ml-2 px-1.5 py-0.5 ${statusBg} bg-opacity-30 rounded">${suggestResponse.status} ${suggestResponse.statusText}</span>
            </div>`);
            
            let retryCount = 0;
            const maxRetries = 2;
            let suggestSuccess = false;
            
            while (retryCount <= maxRetries && !suggestSuccess) {
              try {
                if (retryCount > 0) {
                  addLog(`Retrying URL suggestion (attempt ${retryCount + 1})...`);
                }
                
                if (suggestResponse.ok) {
                  const suggestResult = await suggestResponse.json();
                  
                  // Format and display JSON with syntax highlighting and collapsible structure
                  const jsonStr = JSON.stringify(suggestResult, null, 2);
                  const formattedJson = formatJsonForDisplay(jsonStr);
                  
                  // Determine styling based on success/error status
                  const isError = suggestResult.success === false;
                  const borderColor = isError ? 'border-red-500' : 'border-purple-500';
                  const bgColor = isError ? 'bg-red-900 bg-opacity-20' : 'bg-gray-900';
                  const statusIcon = isError ? '<i class="fas fa-exclamation-triangle text-red-400 mr-1"></i>' : '';
                  const statusText = isError ? 'ERROR' : 'SUCCESS';
                  const statusColor = isError ? 'text-red-400' : 'text-purple-400';
                  
                  addLog(`<div class="json-container ${bgColor} rounded p-2 my-1 border-l-2 ${borderColor} break-words">
                    <div class="flex justify-between items-center mb-1">
                      <div class="flex items-center">
                        ${statusIcon}<span class="text-xs ${statusColor} font-semibold mr-2">${statusText}</span>
                        <button class="text-xs text-gray-400 hover:text-gray-300 px-2 py-0.5 bg-gray-800 rounded toggle-json" onclick="event.preventDefault(); toggleJsonVisibility(this); return false;">
                          <i class="fas fa-chevron-down"></i> <span>Collapse</span>
                        </button>
                      </div>
                      <button class="text-xs text-gray-400 hover:text-gray-300 px-2 py-0.5 bg-gray-800 rounded copy-json" onclick="event.preventDefault(); copyJsonToClipboard(this, '${jsonStr.replace(/'/g, "\\'")}'); return false;" title="Copy JSON">
                        <i class="fas fa-copy"></i> <span>Copy</span>
                      </button>
                    </div>
                    <div class="json-content text-xs font-mono">${formattedJson}</div>
                  </div>`);

                  if (suggestResult.success && suggestResult.suggested_url) {
                    // Read javascript_recommended and settle time from the API response
                    const jsRecommended = suggestResult.javascript_recommended === true;
                    const settleTime = suggestResult.javascript_settle_time_ms || 0;
                    
                    // Store the recommendations for later use in the crawl
                    window.javascriptRecommended = jsRecommended;
                    window.javascriptSettleTime = settleTime;
                    
                    if (jsRecommended) {
                      addLog(`JavaScript recommended for this URL.`);
                      if (settleTime > 0) {
                        addLog(`Recommended settle time: ${settleTime}ms for dynamic content loading.`);
                      }
                    }
                    
                    // Function to use URL in crawler input
                    const useUrlInCrawler = (url) => {
                      // Use React state instead of DOM manipulation for more reliable behavior
                      setInputValue(url);
                      setShowHistory(false);
                      
                      // Schedule a focus on the input field after state update
                      setTimeout(() => {
                        const inputField = document.querySelector('input[placeholder="Enter URL or summon phrase..."]');
                        if (inputField) {
                          inputField.focus();
                        }
                      }, 50);
                    };
                    
                    // Make this function accessible in window scope
                    window.useUrlInCrawler = useUrlInCrawler;
                    
                    // Add "Use this URL" link
                    addLog(`<a href="#" class="text-green-400 hover:text-green-300 hover:underline ml-2" title="Use this URL" onclick="event.preventDefault(); event.stopPropagation(); window.useUrlInCrawler('${suggestResult.suggested_url.replace(/'/g, "\\'")}'); return false;"><i class="fas fa-level-up-alt mr-1"></i>Use this URL</a>`);
                    
                    // Only show the log if the URL actually changed
                    if (suggestResult.suggested_url !== queryUrl) {
                      addLog(`<div class="log-url-info"><span class="text-yellow-400 font-semibold">Translated to URL:</span> <span class="text-green-300">${suggestResult.suggested_url}</span> <a href="#" class="text-green-400 hover:text-green-300 hover:underline ml-2" title="Use this URL" onclick="event.preventDefault(); event.stopPropagation(); window.useUrlInCrawler('${suggestResult.suggested_url.replace(/'/g, "\\'")}'); return false;"><i class="fas fa-level-up-alt mr-1"></i>Use this URL</a></div>`);
                    } else {
                      addLog(`<div class="log-url-info"><span class="text-blue-400 font-semibold">URL confirmed:</span> <span class="text-green-300">${suggestResult.suggested_url}</span> <a href="#" class="text-green-400 hover:text-green-300 hover:underline ml-2" title="Use this URL" onclick="event.preventDefault(); event.stopPropagation(); window.useUrlInCrawler('${suggestResult.suggested_url.replace(/'/g, "\\'")}'); return false;"><i class="fas fa-level-up-alt mr-1"></i>Use this URL</a></div>`);
                    }
                    
                    // Update the query to the suggested URL
                    queryUrl = suggestResult.suggested_url;
                    suggestSuccess = true;
                    
                    // Try crawling with the suggested URL
                    await performCrawl(queryUrl, true);
                  } else {
                    addLog(`Suggestion API response received but no URL suggested.`);
                    suggestSuccess = true;
                  }
                } else {
                  if (retryCount === maxRetries) {
                    // Create a visually distinctive error message
                    addLog(`<div class="bg-red-900 bg-opacity-30 border border-red-700 rounded px-3 py-2 my-2">
                      <div class="flex items-center">
                        <span class="text-red-500 mr-2"><i class="fas fa-exclamation-circle"></i></span>
                        <span class="text-red-400 font-semibold">API suggest failed (${suggestResponse.status})</span>
                      </div>
                      <div class="mt-1 text-red-300">
                        The URL suggestion service returned an error. Using original input: ${queryUrl}
                      </div>
                    </div>`);
                  }
                }
              } catch (retryError) {
                if (retryCount === maxRetries) {
                  // Create a visually distinctive